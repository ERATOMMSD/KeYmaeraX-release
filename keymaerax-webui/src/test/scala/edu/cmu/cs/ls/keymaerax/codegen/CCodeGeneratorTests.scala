/**
  * Copyright (c) Carnegie Mellon University.
  * See LICENSE.txt for the conditions of this license.
  */

package edu.cmu.cs.ls.keymaerax.codegen

import java.io.File

import edu.cmu.cs.ls.keymaerax.bellerophon.SaturateTactic
import edu.cmu.cs.ls.keymaerax.btactics._
import edu.cmu.cs.ls.keymaerax.core.{BaseVariable, Box, Equiv, Formula, Imply, NamedSymbol, Variable}
import edu.cmu.cs.ls.keymaerax.parser.{KeYmaeraXArchiveParser, KeYmaeraXParser}
import edu.cmu.cs.ls.keymaerax.launcher.KeYmaeraX
import edu.cmu.cs.ls.keymaerax.parser.StringConverter._
import testHelper.KeYmaeraXTestTags.IgnoreInBuildTest

/**
 * Tests the C++ ModelPlex code generator.
 * @author Ran Ji
 * @author Stefan Mitsch
 */
class CCodeGeneratorTests extends TacticTestBase {

  override def beforeEach(): Unit = {
    super.beforeEach()
    CPrettyPrinter.printer = new CExpressionPlainPrettyPrinter(printDebugOut = false)
  }

  override def afterEach(): Unit = {
    CPrettyPrinter.printer = new CExpressionPlainPrettyPrinter(printDebugOut = false)
    super.afterEach()
  }

  // terms

  /** Wraps the monitor expression in the monitor boilerplate code. */
  private def expectedMonitor(compiledMonitorExpr: String,
                              paramDecl: String = "", stateDecl: String = "", inputDecl: String = "",
                              definitions: String = "", kind: String = "boolean"): String = {
    val (safetyDistBody, monitorSatisfiedBody) = kind match {
      case "boolean" => (s"return $compiledMonitorExpr ? 1.0L : -1.0L", "boundaryDist(pre,curr,params) >= 0.0L")
      case "program" => (compiledMonitorExpr, "boundaryDist(pre,curr,params) >= 0.0L")
      case "metric" => (
        "return " + compiledMonitorExpr.substring(0, compiledMonitorExpr.indexOf(" >")),
        "boundaryDist(pre,curr,params)" + compiledMonitorExpr.substring(compiledMonitorExpr.indexOf(" >")))
    }

    def structBody(body: String) = if (body.isEmpty) "" else "{\n  " + body + "\n} "

    s"""/**************************
       | *
       | * Generated by KeYmaera X
       | **************************/
       |
       |#include <math.h>
       |#include <stdbool.h>
       |
       |typedef struct parameters ${structBody(paramDecl)}parameters;
       |
       |typedef struct state ${structBody(stateDecl)}state;
       |
       |typedef struct input ${structBody(inputDecl)}input;
       |
       |$definitions
       |
       |/* Computes distance to safety boundary on prior and current state (>=0 is safe, <0 is unsafe) */
       |long double boundaryDist(state pre, state curr, const parameters* const params) {
       |  $safetyDistBody;
       |}
       |
       |/* Evaluates monitor condition in prior and current state */
       |bool monitorSatisfied(state pre, state curr, const parameters* const params) {
       |  return $monitorSatisfiedBody;
       |}
       |
       |/* Run controller `ctrl` monitored, return `fallback` if `ctrl` violates monitor */
       |state monitoredCtrl(state curr, const parameters* const params, const input* const in,
       |                    state (*ctrl)(state,const parameters* const,const input* const), state (*fallback)(state,const parameters* const,const input* const)) {
       |  state pre = curr;
       |  state post = (*ctrl)(pre,params,in);
       |  if (!monitorSatisfied(pre,post,params)) return (*fallback)(pre,params,in);
       |  else return post;
       |}
       |
       |""".stripMargin
  }

  "numbers" should "compile floating point" in {
    val monitor = (new CGenerator(new CMonitorGenerator()))("2+1.5>3.25".asFormula)
    monitor._1 + "\n\n" + monitor._2 shouldBe expectedMonitor("(2.0L)+(1.5L) > 3.25L")
  }

  it should "compile large number" in {
    val monitor = (new CGenerator(new CMonitorGenerator()))("9223372036854775807>1".asFormula)
    monitor._1 + "\n\n" + monitor._2 shouldBe expectedMonitor("9223372036854775807.0L > 1.0L")
  }

  it should "throw exception for too large number" in {
    a [CodeGenerationException] should be thrownBy (new CGenerator(new CMonitorGenerator()))("92233720368547758079>1".asFormula)
  }

  it should "compile to MPFR" in {
    CPrettyPrinter.printer = new CMpfrPrettyPrinter()
    val monitor = (new CGenerator(new CMonitorGenerator()))("2+1.5>3.25".asFormula)
    monitor._1 + "\n\n" + monitor._2 shouldBe expectedMonitor(
      /*"mpfr_cmp(_t_3, _t_0) < 0"*/ "mpfr_get_ld(_t_0, MPFR_RNDD) > mpfr_get_ld(_t_3, MPFR_RNDD)",
      "", "", "",
      """mpfr_t _t_0 /* (2.0L)+(1.5L) */,
        |  _t_1 /* 2.0L */,
        |  _t_2 /* 1.5L */,
        |  _t_3 /* 3.25L */;
        |
        |void mpfrInit() {
        |  mpfr_init2(_t_0, 200);
        |  mpfr_init2(_t_1, 200);
        |  mpfr_init2(_t_2, 200);
        |  mpfr_init2(_t_3, 200);
        |}
        |
        |void mpfrCompute(state pre, state curr, parameters const* const params) {
        |  mpfr_set_ld(_t_1, 2L, MPFR_RNDD);
        |  mpfr_set_ld(_t_2, 1.5L, MPFR_RNDD);
        |  mpfr_set_ld(_t_3, 3.25L, MPFR_RNDD);
        |  mpfr_add(_t_0, _t_1, _t_2, MPFR_RNDD);
        |}""".stripMargin)
  }

  "variables" should "compile with index" in {
    val paramDecls =
      """long double y_1;
        |  long double z;""".stripMargin
    val stateDecls = "long double x;"
    val monitor = (new CGenerator(new CMonitorGenerator()))("x*z-y_1>1".asFormula, Set(Variable("x")))
    monitor._1 + "\n\n" + monitor._2 shouldBe expectedMonitor("((pre.x)*(params->z))-(params->y_1) > 1.0L", paramDecls, stateDecls)
  }

  it should "compile with index to MPFR" in {
    val paramDecls =
      """long double y_1;
        |  long double z;""".stripMargin
    val stateDecls = "long double x;"
    CPrettyPrinter.printer = new CMpfrPrettyPrinter()
    val monitor = (new CGenerator(new CMonitorGenerator()))("x*z-y_1>1".asFormula, Set(Variable("x")))
    monitor._1 + "\n\n" + monitor._2 shouldBe expectedMonitor(
      /*"mpfr_cmp(_t_5, _t_0) < 0"*/ "mpfr_get_ld(_t_0, MPFR_RNDD) > mpfr_get_ld(_t_5, MPFR_RNDD)", paramDecls, stateDecls, "",
      """mpfr_t _t_0 /* ((pre.x)*(params->z))-(params->y_1) */,
        |  _t_1 /* (pre.x)*(params->z) */,
        |  _t_5 /* 1.0L */,
        |  params_y_1 /* params->y_1 */,
        |  params_z /* params->z */,
        |  pre_x /* pre.x */;
        |
        |void mpfrInit() {
        |  mpfr_init2(_t_0, 200);
        |  mpfr_init2(_t_1, 200);
        |  mpfr_init2(_t_5, 200);
        |  mpfr_init2(params_y_1, 200);
        |  mpfr_init2(params_z, 200);
        |  mpfr_init2(pre_x, 200);
        |}
        |
        |void mpfrCompute(state pre, state curr, parameters const* const params) {
        |  mpfr_set_ld(_t_5, 1L, MPFR_RNDD);
        |  mpfr_set_ld(params_y_1, params->y_1, MPFR_RNDD);
        |  mpfr_set_ld(params_z, params->z, MPFR_RNDD);
        |  mpfr_set_ld(pre_x, pre.x, MPFR_RNDD);
        |  mpfr_mul(_t_1, pre_x, params_z, MPFR_RNDD);
        |  mpfr_sub(_t_0, _t_1, params_y_1, MPFR_RNDD);
        |}""".stripMargin)
  }

  "nullary functions" should "compile to parameters" in {
    val monitor = (new CGenerator(new CMonitorGenerator()))("x()>1".asFormula)
    monitor._1 + "\n\n" + monitor._2 shouldBe expectedMonitor("params->x > 1.0L", "long double x;")
  }

  "terms" should "compile plain" in {
    val monitor = (new CGenerator(new CMonitorGenerator()))("x+3*y > 1".asFormula, Set(Variable("x")))
    monitor._1 + "\n\n" + monitor._2 shouldBe expectedMonitor("(pre.x)+((3.0L)*(params->y)) > 1.0L", "long double y;", "long double x;")
  }

  it should "compile with log" in {
    CPrettyPrinter.printer = new CExpressionLogPrettyPrinter()
    val monitor = (new CGenerator(new CMonitorGenerator()))("x+3*y > 1".asFormula, Set(Variable("x")))
    monitor._1 + "\n\n" + monitor._2 shouldBe
      expectedMonitor(
        """eval(gt(plus(variable(pre.x, "pre.x"), times(number(3), variable(params->y, "params->y"))), number(1)))""",
        "long double y;", "long double x;")
  }

  "power" should "compile int exp" in {
    val monitor = (new CGenerator(new CMonitorGenerator()))("x^3>1".asFormula)
    monitor._1 + "\n\n" + monitor._2  shouldBe expectedMonitor("(params->x)*((params->x)*(params->x)) > 1.0L", "long double x;")
  }

  it should "compile exp=1" in {
    val monitor = (new CGenerator(new CMonitorGenerator()))("x^1>1".asFormula)
    monitor._1 + "\n\n" + monitor._2  shouldBe expectedMonitor("params->x > 1.0L", "long double x;")
  }

  it should "compile neg int exp" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    val monitor = (new CGenerator(new CMonitorGenerator()))("(x+y)^-3>1".asFormula)
    monitor._1 + "\n\n" + monitor._2  shouldBe expectedMonitor(
      "(1.0L)/(((params->x)+(params->y))*(((params->x)+(params->y))*((params->x)+(params->y)))) > 1.0L", paramDecls)
  }

  it should "compile any exp" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    val monitor = (new CGenerator(new CMonitorGenerator()))("x^y>1".asFormula)
    monitor._1 + "\n\n" + monitor._2 shouldBe expectedMonitor("pow(params->x,params->y) > 1.0L", paramDecls)
  }

  "abs" should "compile" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    val monitor = (new CGenerator(new CMonitorGenerator()))("abs(x-y)>0".asFormula)
    monitor._1 + "\n\n" + monitor._2  shouldBe expectedMonitor("fabsl((params->x)-(params->y)) > 0.0L", paramDecls)
  }

  "min" should "compile" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    val monitor = (new CGenerator(new CMonitorGenerator()))("min(x,y)<=x".asFormula)
    monitor._1 + "\n\n" + monitor._2 shouldBe expectedMonitor("-(fminl(params->x, params->y)) >= -(params->x)", paramDecls, "", "", "", "metric")
  }

  "max" should "compile" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    val monitor = (new CGenerator(new CMonitorGenerator()))("max(x,y)>=x".asFormula)
    monitor._1 + "\n\n" + monitor._2 shouldBe expectedMonitor("fmaxl(params->x, params->y) >= params->x", paramDecls)
  }

  "A program with tests" should "compile" in withMathematica { _ =>
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    val monitor = (new CGenerator(new CMonitorGenerator()))("<?x>=y;>true".asFormula)
    monitor._1 + "\n\n" + monitor._2 shouldBe expectedMonitor(
      """if (params->x >= params->y) {
        |return (0.0L)+(-((params->y)-(params->x)));
        |} else {
        |return ((-1.0L))+(-((params->y)-(params->x)));
        |}""".stripMargin, paramDecls,
      "", "", "", "program")
  }

  "C generator" should "compile function with 2 parameters" ignore {
    (new CGenerator(new CMonitorGenerator()))("f(x,y)>g(y,z)".asFormula) should be("/**************************\n * Generated by KeYmaera X\n **************************/\n\n" +
      "#include <math.h>\n#include <stdbool.h>\n\n" +
      "/* function declaration */\nlong double f(long double, long double);\nlong double g(long double, long double);\nlong double x();\nlong double y();\nlong double z();\n\n" +
      "/* monitor */\nbool monitor () {\n  return (f(x(), y()))>(g(y(), z()));\n}\n\n")
  }

  it should "compile function with more parameters" ignore {
    (new CGenerator(new CMonitorGenerator()))("f(x,y,z)>0".asFormula) should be("/**************************\n * Generated by KeYmaera X\n **************************/\n\n" +
      "#include <math.h>\n#include <stdbool.h>\n\n" +
      "/* function declaration */\nlong double f(long double, long double, long double);\nlong double x();\nlong double y();\nlong double z();\n\n" +
      "/* monitor */\nbool monitor () {\n  return (f(x(), y(), z()))>((0.0L));\n}\n\n")
  }


  // hacms case studies

  "robix" should "generate C code for passivesafety" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafety.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val paramDecls =
      """long double A;
        |  long double B;
        |  long double V;
        |  long double ep;
        |  long double v;
        |  long double x;
        |  long double y;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dxo;
        |  long double dyo;
        |  long double r;
        |  long double t;
        |  long double w;
        |  long double xo;
        |  long double yo;""".stripMargin
    val genCode = (new CGenerator(new CMonitorGenerator()))(monitorExp, Set(Variable("a"),Variable("w"),Variable("r"),Variable("xo"),Variable("yo"),
      Variable("dxo"),Variable("dyo"),Variable("t")))
    genCode._1 + "\n\n" + genCode._2 shouldBe expectedMonitor(
      "(((curr.dxo)*(curr.dxo))+((curr.dyo)*(curr.dyo)) <= (params->V)*(params->V)) && (((curr.a == -(params->B)) && ((curr.w == pre.w) && ((curr.r == pre.r) && ((curr.xo == pre.xo) && ((curr.yo == pre.yo) && ((curr.dxo == curr.dxo) && ((curr.dyo == curr.dyo) && (curr.t == 0.0L)))))))) || (((params->v == 0.0L) && ((curr.a == 0.0L) && ((curr.w == 0.0L) && ((curr.r == pre.r) && ((curr.xo == pre.xo) && ((curr.yo == pre.yo) && ((curr.dxo == curr.dxo) && ((curr.dyo == curr.dyo) && (curr.t == 0.0L))))))))) || ((-(params->B) <= curr.a) && ((curr.a <= params->A) && ((curr.r != 0.0L) && (((curr.w)*(curr.r) == params->v) && (((((!((params->x)-(curr.xo) >= 0.0L)) || ((params->x)-(curr.xo) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->V)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V))))))) && ((!((params->x)-(curr.xo) <= 0.0L)) || ((curr.xo)-(params->x) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->V)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V)))))))) || (((!((params->y)-(curr.yo) >= 0.0L)) || ((params->y)-(curr.yo) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->V)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V))))))) && ((!((params->y)-(curr.yo) <= 0.0L)) || ((curr.yo)-(params->y) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->V)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V))))))))) && ((curr.a == curr.a) && ((curr.w == curr.w) && ((curr.r == curr.r) && ((curr.xo == curr.xo) && ((curr.yo == curr.yo) && ((curr.dxo == curr.dxo) && ((curr.dyo == curr.dyo) && (curr.t == 0.0L)))))))))))))))",
      paramDecls, stateDecls)
    }

  it should "generate C code for passivesafety_renamed" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafety_renamed.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val paramDecls =
      """long double A;
        |  long double B;
        |  long double Vo;
        |  long double ep;
        |  long double v;
        |  long double x;
        |  long double y;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dxo;
        |  long double dyo;
        |  long double om;
        |  long double r;
        |  long double t;
        |  long double xo;
        |  long double yo;""".stripMargin
    val genCode = (new CGenerator(new CMonitorGenerator()))(monitorExp, Set(Variable("a"),Variable("om"),Variable("r"),Variable("xo"),Variable("yo"),
      Variable("dxo"),Variable("dyo"),Variable("t")))
    genCode._1 + "\n\n" + genCode._2 shouldBe
      expectedMonitor(
        "(((curr.dxo)*(curr.dxo))+((curr.dyo)*(curr.dyo)) <= (params->Vo)*(params->Vo)) && (((curr.a == -(params->B)) && ((curr.om == pre.om) && ((curr.r == pre.r) && ((curr.xo == pre.xo) && ((curr.yo == pre.yo) && ((curr.dxo == curr.dxo) && ((curr.dyo == curr.dyo) && (curr.t == 0.0L)))))))) || (((params->v == 0.0L) && ((curr.a == 0.0L) && ((curr.om == 0.0L) && ((curr.r == pre.r) && ((curr.xo == pre.xo) && ((curr.yo == pre.yo) && ((curr.dxo == curr.dxo) && ((curr.dyo == curr.dyo) && (curr.t == 0.0L))))))))) || ((-(params->B) <= curr.a) && ((curr.a <= params->A) && ((curr.r != 0.0L) && (((curr.om)*(curr.r) == params->v) && (((((!((params->x)-(curr.xo) >= 0.0L)) || ((params->x)-(curr.xo) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->Vo)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->Vo))))))) && ((!((params->x)-(curr.xo) <= 0.0L)) || ((curr.xo)-(params->x) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->Vo)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->Vo)))))))) || (((!((params->y)-(curr.yo) >= 0.0L)) || ((params->y)-(curr.yo) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->Vo)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->Vo))))))) && ((!((params->y)-(curr.yo) <= 0.0L)) || ((curr.yo)-(params->y) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->Vo)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->Vo))))))))) && ((curr.a == curr.a) && ((curr.om == curr.om) && ((curr.r == curr.r) && ((curr.xo == curr.xo) && ((curr.yo == curr.yo) && ((curr.dxo == curr.dxo) && ((curr.dyo == curr.dyo) && (curr.t == 0.0L)))))))))))))))",
        paramDecls, stateDecls)
  }

  it should "generate C code for passivesafetyabs" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val vars =
      Set(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    val paramDecls =
      """long double A;
        |  long double B;
        |  long double V;
        |  long double ep;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dx;
        |  long double dxo;
        |  long double dy;
        |  long double dyo;
        |  long double r;
        |  long double t;
        |  long double v;
        |  long double w;
        |  long double x;
        |  long double xo;
        |  long double y;
        |  long double yo;""".stripMargin
    val genCode = (new CGenerator(new CMonitorGenerator()))(monitorExp, vars)
    genCode._1 + "\n\n" + genCode._2 shouldBe
      expectedMonitor(
        "(((curr.dxo)*(curr.dxo))+((curr.dyo)*(curr.dyo)) <= (params->V)*(params->V)) && ((((0.0L <= params->ep) && (pre.v >= 0.0L)) && (((((((((((((curr.xo == pre.xo) && (curr.yo == pre.yo)) && (curr.dxo == curr.dxo)) && (curr.dyo == curr.dyo)) && (curr.x == pre.x)) && (curr.y == pre.y)) && (curr.dx == pre.dx)) && (curr.dy == pre.dy)) && (curr.v == pre.v)) && (curr.w == pre.w)) && (curr.a == -(params->B))) && (curr.r == pre.r)) && (curr.t == 0.0L))) || (((pre.v == 0.0L) && (((0.0L <= params->ep) && (pre.v >= 0.0L)) && (((((((((((((curr.xo == pre.xo) && (curr.yo == pre.yo)) && (curr.dxo == curr.dxo)) && (curr.dyo == curr.dyo)) && (curr.x == pre.x)) && (curr.y == pre.y)) && (curr.dx == pre.dx)) && (curr.dy == pre.dy)) && (curr.v == pre.v)) && (curr.w == 0.0L)) && (curr.a == 0.0L)) && (curr.r == pre.r)) && (curr.t == 0.0L)))) || (((-(params->B) <= curr.a) && (curr.a <= params->A)) && ((curr.r != 0.0L) && (((curr.w)*(curr.r) == pre.v) && (((fabsl((pre.x)-(curr.xo)) > ((((pre.v)*(pre.v))/((2.0L)*(params->B)))+(((params->V)*(pre.v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((pre.v)+(params->V)))))) || (fabsl((pre.y)-(curr.yo)) > ((((pre.v)*(pre.v))/((2.0L)*(params->B)))+(((params->V)*(pre.v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((pre.v)+(params->V))))))) && (((0.0L <= params->ep) && (pre.v >= 0.0L)) && (((((((((((((curr.xo == curr.xo) && (curr.yo == curr.yo)) && (curr.dxo == curr.dxo)) && (curr.dyo == curr.dyo)) && (curr.x == pre.x)) && (curr.y == pre.y)) && (curr.dx == pre.dx)) && (curr.dy == pre.dy)) && (curr.v == pre.v)) && (curr.w == curr.w)) && (curr.a == curr.a)) && (curr.r == curr.r)) && (curr.t == 0.0L)))))))))",
        paramDecls, stateDecls)
  }

  it should "generate metric C code for passivesafetyabs" in withMathematica { _ =>
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = ModelPlex.toMetric(io.Source.fromInputStream(inputFile).mkString.asFormula)
    val vars =
      Set(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    val paramDecls =
      """long double A;
        |  long double B;
        |  long double V;
        |  long double ep;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dx;
        |  long double dxo;
        |  long double dy;
        |  long double dyo;
        |  long double r;
        |  long double t;
        |  long double v;
        |  long double w;
        |  long double x;
        |  long double xo;
        |  long double y;
        |  long double yo;""".stripMargin
    val genCode = (new CGenerator(new CMonitorGenerator))(monitorExp, vars)
    genCode._1 + "\n\n" + genCode._2 shouldBe
      expectedMonitor(
        "-(fmaxl((((curr.dxo)*(curr.dxo))+((curr.dyo)*(curr.dyo)))-((params->V)*(params->V)), fminl(fmaxl(fmaxl((0.0L)-(params->ep), (0.0L)-(pre.v)), fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl((curr.xo)-(pre.xo), (pre.xo)-(curr.xo)), fmaxl((curr.yo)-(pre.yo), (pre.yo)-(curr.yo))), fmaxl((curr.dxo)-(curr.dxo), (curr.dxo)-(curr.dxo))), fmaxl((curr.dyo)-(curr.dyo), (curr.dyo)-(curr.dyo))), fmaxl((curr.x)-(pre.x), (pre.x)-(curr.x))), fmaxl((curr.y)-(pre.y), (pre.y)-(curr.y))), fmaxl((curr.dx)-(pre.dx), (pre.dx)-(curr.dx))), fmaxl((curr.dy)-(pre.dy), (pre.dy)-(curr.dy))), fmaxl((curr.v)-(pre.v), (pre.v)-(curr.v))), fmaxl((curr.w)-(pre.w), (pre.w)-(curr.w))), fmaxl((curr.a)-(-(params->B)), (-(params->B))-(curr.a))), fmaxl((curr.r)-(pre.r), (pre.r)-(curr.r))), fmaxl(curr.t, (0.0L)-(curr.t)))), fminl(fmaxl(fmaxl(pre.v, (0.0L)-(pre.v)), fmaxl(fmaxl((0.0L)-(params->ep), (0.0L)-(pre.v)), fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl((curr.xo)-(pre.xo), (pre.xo)-(curr.xo)), fmaxl((curr.yo)-(pre.yo), (pre.yo)-(curr.yo))), fmaxl((curr.dxo)-(curr.dxo), (curr.dxo)-(curr.dxo))), fmaxl((curr.dyo)-(curr.dyo), (curr.dyo)-(curr.dyo))), fmaxl((curr.x)-(pre.x), (pre.x)-(curr.x))), fmaxl((curr.y)-(pre.y), (pre.y)-(curr.y))), fmaxl((curr.dx)-(pre.dx), (pre.dx)-(curr.dx))), fmaxl((curr.dy)-(pre.dy), (pre.dy)-(curr.dy))), fmaxl((curr.v)-(pre.v), (pre.v)-(curr.v))), fmaxl(curr.w, (0.0L)-(curr.w))), fmaxl(curr.a, (0.0L)-(curr.a))), fmaxl((curr.r)-(pre.r), (pre.r)-(curr.r))), fmaxl(curr.t, (0.0L)-(curr.t))))), fmaxl(fmaxl((-(params->B))-(curr.a), (curr.a)-(params->A)), fmaxl(fminl((0.0L)-(curr.r), curr.r), fmaxl(fmaxl(((curr.w)*(curr.r))-(pre.v), (pre.v)-((curr.w)*(curr.r))), fmaxl(fminl((((((pre.v)*(pre.v))/((2.0L)*(params->B)))+(((params->V)*(pre.v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((pre.v)+(params->V))))))-(fabsl((pre.x)+(-(curr.xo)))), (((((pre.v)*(pre.v))/((2.0L)*(params->B)))+(((params->V)*(pre.v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((pre.v)+(params->V))))))-(fabsl((pre.y)+(-(curr.yo))))), fmaxl(fmaxl((0.0L)-(params->ep), (0.0L)-(pre.v)), fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl((curr.xo)-(curr.xo), (curr.xo)-(curr.xo)), fmaxl((curr.yo)-(curr.yo), (curr.yo)-(curr.yo))), fmaxl((curr.dxo)-(curr.dxo), (curr.dxo)-(curr.dxo))), fmaxl((curr.dyo)-(curr.dyo), (curr.dyo)-(curr.dyo))), fmaxl((curr.x)-(pre.x), (pre.x)-(curr.x))), fmaxl((curr.y)-(pre.y), (pre.y)-(curr.y))), fmaxl((curr.dx)-(pre.dx), (pre.dx)-(curr.dx))), fmaxl((curr.dy)-(pre.dy), (pre.dy)-(curr.dy))), fmaxl((curr.v)-(pre.v), (pre.v)-(curr.v))), fmaxl((curr.w)-(curr.w), (curr.w)-(curr.w))), fmaxl((curr.a)-(curr.a), (curr.a)-(curr.a))), fmaxl((curr.r)-(curr.r), (curr.r)-(curr.r))), fmaxl(curr.t, (0.0L)-(curr.t)))))))))))) > -(0.0L)",
        paramDecls, stateDecls, "", "", "metric")
  }

  it should "generate C code for passivesafetyabs with KeYmaeraX command line interface" taggedAs IgnoreInBuildTest in {
    // command line main has to initialize the prover itself, so dispose all test setup first
//    afterEach()

    val inputFileName = "./keymaerax-webui/src/test/resources/examples/casestudies/robix/passivesafetyabs.kym"
    val outputFileName = File.createTempFile("passivesafetyabs", ".c").getAbsolutePath

    KeYmaeraX.main(Array("-codegen", inputFileName, "-vars", "a,w,r,xo,yo,dxo,dyo", "-nointerval", "-out", outputFileName))

    val expectedCCode = scala.io.Source.fromFile("./keymaerax-webui/src/test/resources/examples/casestudies/robix/passivesafetyabs.c").mkString
    val actualFileContent = scala.io.Source.fromFile(outputFileName).mkString
    println(actualFileContent)

    actualFileContent should include (expectedCCode)
  }

  it should "generate C code for passiveorientationsafety" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passiveorientationsafety.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val paramDecls =
      """long double A;
        |  long double V;
        |  long double alpha;
        |  long double b;
        |  long double ep;
        |  long double v;
        |  long double x;
        |  long double y;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dx;
        |  long double dy;
        |  long double isVisible;
        |  long double odx;
        |  long double ody;
        |  long double ox;
        |  long double oy;
        |  long double r;
        |  long double t;
        |  long double talpha;
        |  long double w;""".stripMargin
    val genCode = (new CGenerator(new CMonitorGenerator()))(monitorExp,
      Set(Variable("a"), Variable("w"), Variable("dx"), Variable("dy"), Variable("r"), Variable("t"), Variable("ox"),
           Variable("oy"), Variable("odx"), Variable("ody"), Variable("isVisible"),
           Variable("talpha")))
    genCode._1 + "\n\n" + genCode._2 shouldBe
      expectedMonitor(
        "(((curr.odx)*(curr.odx))+((curr.ody)*(curr.ody)) <= (params->V)*(params->V)) && ((((curr.w)*(pre.r) == params->v) && ((curr.a == -(params->b)) && ((curr.w == curr.w) && ((curr.dx == pre.dx) && ((curr.dy == pre.dy) && ((curr.r == pre.r) && ((curr.t == 0.0L) && ((curr.ox == pre.ox) && ((curr.oy == pre.oy) && ((curr.odx == curr.odx) && ((curr.ody == curr.ody) && ((curr.isVisible == pre.isVisible) && (curr.talpha == pre.talpha))))))))))))) || (((params->v == 0.0L) && (((curr.w)*(pre.r) == params->v) && ((curr.a == 0.0L) && ((curr.w == curr.w) && ((curr.dx == -(pre.dx)) && ((curr.dy == -(pre.dy)) && ((curr.r == pre.r) && ((curr.t == 0.0L) && ((curr.ox == pre.ox) && ((curr.oy == pre.oy) && ((curr.odx == curr.odx) && ((curr.ody == curr.ody) && ((curr.isVisible == pre.isVisible) && (curr.talpha == pre.talpha)))))))))))))) || ((-(params->b) <= curr.a) && ((curr.a <= params->A) && ((curr.r != 0.0L) && ((((params->v)+((curr.a)*(params->ep)) < 0.0L) && (((curr.isVisible < 0.0L) || ((((!((params->x)-(curr.ox) >= 0.0L)) || ((params->x)-(curr.ox) > (((params->v)*(params->v))/(((-2.0L))*(curr.a)))+((params->V)*((params->v)/(-(curr.a)))))) && ((!((params->x)-(curr.ox) <= 0.0L)) || ((curr.ox)-(params->x) > (((params->v)*(params->v))/(((-2.0L))*(curr.a)))+((params->V)*((params->v)/(-(curr.a))))))) || (((!((params->y)-(curr.oy) >= 0.0L)) || ((params->y)-(curr.oy) > (((params->v)*(params->v))/(((-2.0L))*(curr.a)))+((params->V)*((params->v)/(-(curr.a)))))) && ((!((params->y)-(curr.oy) <= 0.0L)) || ((curr.oy)-(params->y) > (((params->v)*(params->v))/(((-2.0L))*(curr.a)))+((params->V)*((params->v)/(-(curr.a))))))))) && (((!(curr.r >= 0.0L)) || (((params->v)*(params->v))/(((-2.0L))*(curr.a)) < (params->alpha)*(curr.r))) && (((!(curr.r < 0.0L)) || (((params->v)*(params->v))/(((-2.0L))*(curr.a)) < -((params->alpha)*(curr.r)))) && (((curr.w)*(curr.r) == params->v) && ((curr.a == curr.a) && ((curr.w == curr.w) && ((curr.dx == pre.dx) && ((curr.dy == pre.dy) && ((curr.r == curr.r) && ((curr.t == 0.0L) && ((curr.ox == curr.ox) && ((curr.oy == curr.oy) && ((curr.odx == curr.odx) && ((curr.ody == curr.ody) && ((curr.isVisible == curr.isVisible) && (curr.talpha == 0.0L))))))))))))))))) || (((params->v)+((curr.a)*(params->ep)) >= 0.0L) && (((curr.isVisible < 0.0L) || ((((!((params->x)-(curr.ox) >= 0.0L)) || ((params->x)-(curr.ox) > ((((params->v)*(params->v))/((2.0L)*(params->b)))+((params->V)*((params->v)/(params->b))))+((((curr.a)/(params->b))+(1.0L))*((((curr.a)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V))))))) && ((!((params->x)-(curr.ox) <= 0.0L)) || ((curr.ox)-(params->x) > ((((params->v)*(params->v))/((2.0L)*(params->b)))+((params->V)*((params->v)/(params->b))))+((((curr.a)/(params->b))+(1.0L))*((((curr.a)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V)))))))) || (((!((params->y)-(curr.oy) >= 0.0L)) || ((params->y)-(curr.oy) > ((((params->v)*(params->v))/((2.0L)*(params->b)))+((params->V)*((params->v)/(params->b))))+((((curr.a)/(params->b))+(1.0L))*((((curr.a)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V))))))) && ((!((params->y)-(curr.oy) <= 0.0L)) || ((curr.oy)-(params->y) > ((((params->v)*(params->v))/((2.0L)*(params->b)))+((params->V)*((params->v)/(params->b))))+((((curr.a)/(params->b))+(1.0L))*((((curr.a)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V)))))))))) && (((!(curr.r >= 0.0L)) || ((((params->v)*(params->v))/((2.0L)*(params->b)))+((((curr.a)/(params->b))+(1.0L))*((((curr.a)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*(params->v)))) < (params->alpha)*(curr.r))) && (((!(curr.r < 0.0L)) || ((((params->v)*(params->v))/((2.0L)*(params->b)))+((((curr.a)/(params->b))+(1.0L))*((((curr.a)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*(params->v)))) < -((params->alpha)*(curr.r)))) && (((curr.w)*(curr.r) == params->v) && ((curr.a == curr.a) && ((curr.w == curr.w) && ((curr.dx == pre.dx) && ((curr.dy == pre.dy) && ((curr.r == curr.r) && ((curr.t == 0.0L) && ((curr.ox == curr.ox) && ((curr.oy == curr.oy) && ((curr.odx == curr.odx) && ((curr.ody == curr.ody) && ((curr.isVisible == curr.isVisible) && (curr.talpha == 0.0L)))))))))))))))))))))))",
        paramDecls, stateDecls)
  }

  "quadcopter" should "generate C code for hybridquadrotor" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/quadcopter/hybridquadrotor.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val paramDecls =
      """long double h;
        |  long double kd;
        |  long double kp;
        |  long double sqrkp;
        |  long double v;
        |  long double y;""".stripMargin
    val code = (new CGenerator(new CMonitorGenerator()))(monitorExp, Set(Variable("href")))
    println(code)
    code._1 + "\n\n" + code._2 shouldBe expectedMonitor(
      "(params->h >= curr.href) && ((curr.href > 0.0L) && ((((((params->kp < 0.0L) && ((params->v == 0.0L) && (curr.href >= params->h))) || (((params->kp < 0.0L) && ((params->v > 0.0L) && (((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) == ((2.0L)*(curr.href))*(params->kp)) && ((params->h)*(params->y) > ((params->h)*(params->kd))+((2.0L)*(params->v)))))) || (((params->kp < 0.0L) && ((params->v < 0.0L) && (((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) == (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && (((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) > 0.0L)))) || (((params->kp > 0.0L) && ((params->v == 0.0L) && (curr.href == params->h))) || (((params->kp > 0.0L) && ((params->v > 0.0L) && ((((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) == ((2.0L)*(curr.href))*(params->kp)) && (((params->h)*(params->y) > ((params->h)*(params->kd))+((2.0L)*(params->v))) && ((params->kd)+((2.0L)*(params->sqrkp)) <= 0.0L))) || ((((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) == ((2.0L)*(curr.href))*(params->kp)) && (((params->kd)+((2.0L)*(params->sqrkp)) < 0.0L) && (((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) < 0.0L))) || ((((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) == (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && (((params->kd)+((2.0L)*(params->sqrkp)) < 0.0L) && (((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) < 0.0L))) || (((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) == ((2.0L)*(curr.href))*(params->kp)) && ((params->kd > (2.0L)*(params->sqrkp)) && ((((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) > 0.0L) && ((params->h)*(params->y) >= ((params->h)*(params->kd))+((2.0L)*(params->v))))))))))) || ((params->kp > 0.0L) && ((params->v < 0.0L) && ((((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) == ((2.0L)*(curr.href))*(params->kp)) && ((params->kd > (2.0L)*(params->sqrkp)) && ((params->h)*(params->y) < ((params->h)*(params->kd))+((2.0L)*(params->v))))) || ((((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) == (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && ((params->kd >= (2.0L)*(params->sqrkp)) && ((params->h)*(params->y) < ((params->h)*(params->kd))+((2.0L)*(params->v))))) || ((((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) == (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && ((params->kd > (2.0L)*(params->sqrkp)) && ((((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) > 0.0L) && ((params->h)*(params->y) >= ((params->h)*(params->kd))+((2.0L)*(params->v)))))) || (((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) == (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && (((params->h)*(params->y) > ((params->h)*(params->kd))+((2.0L)*(params->v))) && ((((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) >= 0.0L) && ((params->kd)+((2.0L)*(params->sqrkp)) < 0.0L)))))))))))))) && ((((params->y)*(params->y) == ((params->kd)*(params->kd))-((4.0L)*(params->kp))) && (params->y >= 0.0L)) && ((((params->sqrkp)*(params->sqrkp) == params->kp) && (params->sqrkp >= 0.0L)) && ((((((((params->h)*(params->h))*((params->kp)*(params->kp)))-((((2.0L)*(params->h))*(curr.href))*((params->kp)*(params->kp))))+(((curr.href)*(curr.href))*((params->kp)*(params->kp))))+((((params->h)*(params->kd))*(params->kp))*(params->v)))-((((curr.href)*(params->kd))*(params->kp))*(params->v)))+((params->kp)*((params->v)*(params->v))) != 0.0L)))) || ((((params->kp < 0.0L) && ((params->v == 0.0L) && (((params->h)*(params->y) <= (params->h)*(params->kd)) || (((params->h)*((params->kd)+(params->y)) <= 0.0L) || (params->h > curr.href))))) || (((params->kp < 0.0L) && ((params->v < 0.0L) && (((params->h)*(params->y) <= ((params->h)*(params->kd))+((2.0L)*(params->v))) || ((((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) <= 0.0L) || ((((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v)) != (((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y))))))) || (((params->kp < 0.0L) && ((params->v > 0.0L) && (((params->h)*(params->y) <= ((params->h)*(params->kd))+((2.0L)*(params->v))) || ((((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) <= 0.0L) || ((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) != ((2.0L)*(curr.href))*(params->kp)))))) || (((params->kp > 0.0L) && ((params->v == 0.0L) && (((params->h != curr.href) && (((params->kd >= (2.0L)*(params->sqrkp)) && ((params->h)*(params->y) >= (params->h)*(params->kd))) || (((params->h)*((params->kd)+(params->y)) >= 0.0L) && ((params->kd)+((2.0L)*(params->sqrkp)) < 0.0L)))) || (((params->kd == (2.0L)*(params->sqrkp)) && ((params->h)*(params->y) >= (params->h)*(params->kd))) || (((params->kd < (2.0L)*(params->sqrkp)) && ((params->kd)+((2.0L)*(params->sqrkp)) > 0.0L)) || ((params->h > curr.href) || (((params->kd > (2.0L)*(params->sqrkp)) && ((params->h)*((params->kd)+(params->y)) <= 0.0L)) || (((params->kd)+((2.0L)*(params->sqrkp)) <= 0.0L) && ((params->h)*(params->y) <= (params->h)*(params->kd)))))))))) || (((params->kp > 0.0L) && ((params->v < 0.0L) && ((((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) != (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && (((params->h)*(params->y) >= ((params->h)*(params->kd))+((2.0L)*(params->v))) || (params->kd <= (2.0L)*(params->sqrkp)))) || ((params->kd < (2.0L)*(params->sqrkp)) || (((params->kd > (2.0L)*(params->sqrkp)) && ((((params->h)*(params->y) < ((params->h)*(params->kd))+((2.0L)*(params->v))) && ((((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) < (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && ((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) < ((2.0L)*(curr.href))*(params->kp))) || (((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) > (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) || ((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) > ((2.0L)*(curr.href))*(params->kp))))) || (((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) <= 0.0L))) || ((((params->h)*(params->y) >= ((params->h)*(params->kd))+((2.0L)*(params->v))) && (params->kd <= (2.0L)*(params->sqrkp))) || ((params->kd)+((2.0L)*(params->sqrkp)) <= 0.0L))))))) || ((params->kp > 0.0L) && ((params->v > 0.0L) && ((((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) != ((2.0L)*(curr.href))*(params->kp)) && (((params->kd)+((2.0L)*(params->sqrkp)) >= 0.0L) || (((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) >= 0.0L))) || ((params->kd >= (2.0L)*(params->sqrkp)) || ((((params->kd)+((2.0L)*(params->sqrkp)) < 0.0L) && ((((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) < 0.0L) && (((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) < (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) || (((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) < ((2.0L)*(curr.href))*(params->kp)) || (((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) > (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && ((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) > ((2.0L)*(curr.href))*(params->kp))))))) || (((params->kd)+((2.0L)*(params->sqrkp)) > 0.0L) || ((params->h)*(params->y) <= ((params->h)*(params->kd))+((2.0L)*(params->v)))))))))))))) && (((params->y)*(params->y) == ((params->kd)*(params->kd))-((4.0L)*(params->kp))) && ((params->y >= 0.0L) && (((params->sqrkp)*(params->sqrkp) == params->kp) && ((params->sqrkp >= 0.0L) && ((((((((params->h)*(params->h))*((params->kp)*(params->kp)))-((((2.0L)*(params->h))*(curr.href))*((params->kp)*(params->kp))))+(((curr.href)*(curr.href))*((params->kp)*(params->kp))))+((((params->h)*(params->kd))*(params->kp))*(params->v)))-((((curr.href)*(params->kd))*(params->kp))*(params->v)))+((params->kp)*((params->v)*(params->v))) == 0.0L))))))) && (curr.href == curr.href)))",
      paramDecls, "long double href;")
    CodeGenTestTools.compileC(CodeGenTestTools.augmentMonitorMain(code._1 + "\n\n" + code._2, hasParams=true, hasInputs=false))
  }

  "Waypoint navigation" should "generate metric C code" in withMathematica { tool =>
    //@note run this test with -DTEST_BASE_DIR=/path/to/modeldirectory
    val baseDir = System.getProperty("TEST_BASE_DIR")
    val model = KeYmaeraXArchiveParser.parseFromFile(s"$baseDir/relative-full.kyx#Theorem 1: Safety").head.model.asInstanceOf[Formula]
    val Imply(_, Box(prg, _)) = model

    val stateVars = ("xg"::"yg"::"v"::"a"::"t"::"vl"::"vh"::"k"::Nil).map(_.asVariable.asInstanceOf[BaseVariable])
    val (modelplexInput, assumptions) = ModelPlex.createMonitorSpecificationConjecture(model, stateVars:_*)
    val simplifier = SimplifierV3.simpTac(taxs = SimplifierV3.composeIndex(
      SimplifierV3.groundEqualityIndex, SimplifierV3.defaultTaxs))
    val tactic = ModelPlex.controllerMonitorByChase(1) & DebuggingTactics.print("Chased") &
      SaturateTactic(ModelPlex.optimizationOneWithSearch(Some(tool), assumptions)(1)) &
      DebuggingTactics.print("Quantifiers instantiated") &
      simplifier(1) & DebuggingTactics.print("Simplified")
    val result = proveBy(modelplexInput, tactic)
    val monitorFml = result.subgoals.head.succ.head
    val reassociatedMonitorFml = FormulaTools.reassociate(monitorFml)
    proveBy(Equiv(monitorFml, reassociatedMonitorFml), TactixLibrary.prop) shouldBe 'proved

    val testProg = proveBy(reassociatedMonitorFml, ModelPlex.chaseToTests(combineTests=false)(1)*2).subgoals.head.succ.head

    // CPrettyPrinter.printer = new CMpfrPrettyPrinter()
    val inputs = CGenerator.getInputs(testProg)
    val monitorCode = (new CGenerator(new CMonitorGenerator()))(testProg, stateVars.toSet, inputs, "Monitor")

    //val controlCode = (new CGenerator(new CMpfrControllerGenerator()))(prg, stateVars.toSet, inputs, "Controller")
    //val controlCode = (new CGenerator(new CControllerGenerator()))(prg, stateVars.toSet, inputs, "Controller")
    //val controlCode = (new CGenerator(new CDetControllerGenerator()))(prg, stateVars.toSet, inputs, "Controller")
    monitorCode._1 + monitorCode._2 shouldBe
      """/**************************
        | * Monitor.c
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double A;
        |  long double B;
        |  long double T;
        |  long double eps;
        |} parameters;
        |
        |typedef struct state {
        |  long double a;
        |  long double k;
        |  long double t;
        |  long double v;
        |  long double vh;
        |  long double vl;
        |  long double xg;
        |  long double yg;
        |} state;
        |
        |typedef struct input input;
        |
        |/* Computes distance to safety boundary on prior and current state (>=0 is safe, <0 is unsafe) */
        |long double boundaryDist(state pre, state curr, const parameters* const params) {
        |  if (((curr.xg >= 0.0L) && (curr.k >= 0.0L)) || ((curr.xg <= 0.0L) && (curr.k <= 0.0L))) {
        |if (curr.yg > 0.0L) {
        |if ((fabsl(curr.k))*(params->eps) <= 100.0L) {
        |if ((((curr.k)*((params->eps)*(params->eps)))-((200.0L)*(params->eps)))*(100.0L) < ((curr.k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))-((((2.0L)*(curr.xg))*(100.0L))*(10.0L))) {
        |if (((curr.k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))-((((2.0L)*(curr.xg))*(100.0L))*(10.0L)) < (((curr.k)*((params->eps)*(params->eps)))+((200.0L)*(params->eps)))*(100.0L)) {
        |if (0.0L <= curr.vl) {
        |if (curr.vl < curr.vh) {
        |if ((params->A)*(params->T) <= (10.0L)*((curr.vh)-(curr.vl))) {
        |if ((params->B)*(params->T) <= (10.0L)*((curr.vh)-(curr.vl))) {
        |if (-(params->B) <= curr.a) {
        |if (curr.a <= params->A) {
        |if (((10.0L)*(pre.v))+((curr.a)*(params->T)) >= 0.0L) {
        |if (((pre.v <= curr.vh) && (((10.0L)*(pre.v))+((curr.a)*(params->T)) <= (10.0L)*(curr.vh))) || (((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->B)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+(((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))-(((10.0L)*(curr.vh))*((10.0L)*(curr.vh))))) <= ((((2.0L)*(params->B))*((fabsl(curr.xg))-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)) || ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->B)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+(((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))-(((10.0L)*(curr.vh))*((10.0L)*(curr.vh))))) <= ((((2.0L)*(params->B))*((curr.yg)-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)))) {
        |if (((curr.vl <= pre.v) && (((10.0L)*(pre.v))+((curr.a)*(params->T)) >= (10.0L)*(curr.vl))) || (((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->A)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+((((curr.vl)*(10.0L))*((curr.vl)*(10.0L)))-((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T)))))) <= ((((2.0L)*(params->A))*((fabsl(curr.xg))-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)) || ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->A)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+((((curr.vl)*(10.0L))*((curr.vl)*(10.0L)))-((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T)))))) <= ((((2.0L)*(params->A))*((curr.yg)-((10.0L)*(params->eps))))*(10000.0L))*(100.0L)))) {
        |if (pre.v >= 0.0L) {
        |if (0.0L <= params->T) {
        |if (curr.v == pre.v) {
        |if (curr.t == 0.0L) {
        |return ((((((((((((((((0.0L)+(-(fminl(fmaxl((0.0L)-(curr.xg), (0.0L)-(curr.k)), fmaxl(curr.xg, curr.k)))))+(-((0.0L)-(curr.yg))))+(-(((fabsl(curr.k))*(params->eps))-(100.0L))))+(-(((((curr.k)*((params->eps)*(params->eps)))+(-((200.0L)*(params->eps))))*(100.0L))-(((curr.k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))+(-((((2.0L)*(curr.xg))*(100.0L))*(10.0L)))))))+(-((((curr.k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))+(-((((2.0L)*(curr.xg))*(100.0L))*(10.0L))))-((((curr.k)*((params->eps)*(params->eps)))+((200.0L)*(params->eps)))*(100.0L)))))+(-((0.0L)-(curr.vl))))+(-((curr.vl)-(curr.vh))))+(-(((params->A)*(params->T))-((10.0L)*((curr.vh)+(-(curr.vl)))))))+(-(((params->B)*(params->T))-((10.0L)*((curr.vh)+(-(curr.vl)))))))+(-((-(params->B))-(curr.a))))+(-((curr.a)-(params->A))))+(-((0.0L)-(((10.0L)*(pre.v))+((curr.a)*(params->T))))))+(-(fminl(fmaxl((pre.v)-(curr.vh), (((10.0L)*(pre.v))+((curr.a)*(params->T)))-((10.0L)*(curr.vh))), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->B)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+(((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))+(-(((10.0L)*(curr.vh))*((10.0L)*(curr.vh)))))))-(((((2.0L)*(params->B))*((fabsl(curr.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->B)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+(((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))+(-(((10.0L)*(curr.vh))*((10.0L)*(curr.vh)))))))-(((((2.0L)*(params->B))*((curr.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)))))))+(-(fminl(fmaxl((curr.vl)-(pre.v), ((10.0L)*(curr.vl))-(((10.0L)*(pre.v))+((curr.a)*(params->T)))), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->A)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+((((curr.vl)*(10.0L))*((curr.vl)*(10.0L)))+(-((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))))))-(((((2.0L)*(params->A))*((fabsl(curr.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->A)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+((((curr.vl)*(10.0L))*((curr.vl)*(10.0L)))+(-((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))))))-(((((2.0L)*(params->A))*((curr.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)))))))+(-((0.0L)-(pre.v))))+(-((0.0L)-(params->T)));
        |} else {
        |return -1.0L;
        |}
        |} else {
        |return -1.0L;
        |}
        |} else {
        |return ((-1.0L))+(-((0.0L)-(params->T)));
        |}
        |} else {
        |return ((-1.0L))+(-((0.0L)-(pre.v)));
        |}
        |} else {
        |return ((-1.0L))+(-(fminl(fmaxl((curr.vl)-(pre.v), ((10.0L)*(curr.vl))-(((10.0L)*(pre.v))+((curr.a)*(params->T)))), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->A)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+((((curr.vl)*(10.0L))*((curr.vl)*(10.0L)))+(-((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))))))-(((((2.0L)*(params->A))*((fabsl(curr.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->A)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+((((curr.vl)*(10.0L))*((curr.vl)*(10.0L)))+(-((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))))))-(((((2.0L)*(params->A))*((curr.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L))))));
        |}
        |} else {
        |return ((-1.0L))+(-(fminl(fmaxl((pre.v)-(curr.vh), (((10.0L)*(pre.v))+((curr.a)*(params->T)))-((10.0L)*(curr.vh))), fminl(((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->B)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+(((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))+(-(((10.0L)*(curr.vh))*((10.0L)*(curr.vh)))))))-(((((2.0L)*(params->B))*((fabsl(curr.xg))+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L)), ((((10000.0L)+((((2.0L)*(params->eps))*(fabsl(curr.k)))*(100.0L)))+(((params->eps)*(params->eps))*((curr.k)*(curr.k))))*(((params->B)*(((((2.0L)*(pre.v))*(params->T))*(10.0L))+((curr.a)*((params->T)*(params->T)))))+(((((pre.v)*(10.0L))+((curr.a)*(params->T)))*(((pre.v)*(10.0L))+((curr.a)*(params->T))))+(-(((10.0L)*(curr.vh))*((10.0L)*(curr.vh)))))))-(((((2.0L)*(params->B))*((curr.yg)+(-((10.0L)*(params->eps)))))*(10000.0L))*(100.0L))))));
        |}
        |} else {
        |return ((-1.0L))+(-((0.0L)-(((10.0L)*(pre.v))+((curr.a)*(params->T)))));
        |}
        |} else {
        |return ((-1.0L))+(-((curr.a)-(params->A)));
        |}
        |} else {
        |return ((-1.0L))+(-((-(params->B))-(curr.a)));
        |}
        |} else {
        |return ((-1.0L))+(-(((params->B)*(params->T))-((10.0L)*((curr.vh)+(-(curr.vl))))));
        |}
        |} else {
        |return ((-1.0L))+(-(((params->A)*(params->T))-((10.0L)*((curr.vh)+(-(curr.vl))))));
        |}
        |} else {
        |return ((-1.0L))+(-((curr.vl)-(curr.vh)));
        |}
        |} else {
        |return ((-1.0L))+(-((0.0L)-(curr.vl)));
        |}
        |} else {
        |return ((-1.0L))+(-((((curr.k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))+(-((((2.0L)*(curr.xg))*(100.0L))*(10.0L))))-((((curr.k)*((params->eps)*(params->eps)))+((200.0L)*(params->eps)))*(100.0L))));
        |}
        |} else {
        |return ((-1.0L))+(-(((((curr.k)*((params->eps)*(params->eps)))+(-((200.0L)*(params->eps))))*(100.0L))-(((curr.k)*(((curr.xg)*(curr.xg))+((curr.yg)*(curr.yg))))+(-((((2.0L)*(curr.xg))*(100.0L))*(10.0L))))));
        |}
        |} else {
        |return ((-1.0L))+(-(((fabsl(curr.k))*(params->eps))-(100.0L)));
        |}
        |} else {
        |return ((-1.0L))+(-((0.0L)-(curr.yg)));
        |}
        |} else {
        |return ((-1.0L))+(-(fminl(fmaxl((0.0L)-(curr.xg), (0.0L)-(curr.k)), fmaxl(curr.xg, curr.k))));
        |};
        |}
        |
        |/* Evaluates monitor condition in prior and current state */
        |bool monitorSatisfied(state pre, state curr, const parameters* const params) {
        |  return boundaryDist(pre,curr,params) >= 0.0L;
        |}
        |
        |/* Run controller `ctrl` monitored, return `fallback` if `ctrl` violates monitor */
        |state monitoredCtrl(state curr, const parameters* const params, const input* const in,
        |                    state (*ctrl)(state,const parameters* const,const input* const), state (*fallback)(state,const parameters* const,const input* const)) {
        |  state pre = curr;
        |  state post = (*ctrl)(pre,params,in);
        |  if (!monitorSatisfied(pre,post,params)) return (*fallback)(pre,params,in);
        |  else return post;
        |}
        |
        |""".stripMargin
  }

  "Compiled controller monitor" should "evaluate boolean correctly" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val vars =
      Set(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    val genCode = (new CGenerator(new CMonitorGenerator()))(monitorExp, vars)
    val monitorCode = genCode._1 + "\n\n" + genCode._2

    // robot and obstacle drive straight towards each other
    val code =
      s"""
        |#include <stdio.h>
        |$monitorCode
        |
        |state ctrl(state curr, const parameters* const params, const input* const in) { printf("Controller chooses A\\n"); curr.a = params->A; return curr; }
        |state fallback(state curr, const parameters* const params, const input* const in) { printf("Fallback returns -B\\n"); curr.a = -params->B; return curr; }
        |
        |int main() {
        |  state current = { .a=0.0, .dx=1.0, .dy=0.0, .r=1.0, .v=1.0, .w=1.0, .x=0.0, .y=0.0, .xo=10.0, .yo=0.0, .dxo=-1.0, .dyo=0.0, .t=0.0 };
        |  parameters params = { .A=1.0, .B=2.0, .V=1.0, .ep=0.05 };
        |  printf("Returned a=%1.1Lf\\n", monitoredCtrl(current, &params, (const input* const)0, &ctrl, &fallback).a);
        |  /* jump robot ahead and speed up, now unsafe */
        |  state next = { .a=0.0, .dx=1.0, .dy=0.0, .r=1.0, .v=4.0, .w=4.0, .x=9.0, .y=0.0, .xo=10.0, .yo=0.0, .dxo=-1.0, .dyo=0.0 };
        |  printf("Returned a=%1.1Lf", monitoredCtrl(next, &params, (const input* const)0, &ctrl, &fallback).a);
        |  return 0;
        |}
        |""".stripMargin

    val cmd = CodeGenTestTools.compileC(code)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        "Controller chooses A\nReturned a=1.0\nController chooses A\nFallback returns -B\nReturned a=-2.0"
    }
  }

  it should "evaluate metric correctly" ignore withMathematica { _ =>
    //@todo mixed open/closed can evaluate to false at the boundary (e.g., x<=5 | x>6 turns into min(x-5,6-x)<0 == false for x=5)
    //      which is especially problematic when monitor contains equalities, e.g., x=5 | x>6
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = ModelPlex.toMetric(io.Source.fromInputStream(inputFile).mkString.asFormula)
    val vars =
      Set(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    val monitorCode = (new CGenerator(new CMonitorGenerator))(monitorExp, vars)

    // robot and obstacle drive straight towards each other
    val code =
      s"""
         |#include <stdio.h>
         |$monitorCode
         |
         |state ctrl(state curr, parameters params, input input) { printf("Controller chooses A\\n"); curr.a = params->A; return curr; }
         |state fallback(state curr, parameters params, input input) { printf("Fallback returns -B\\n"); curr.a = -params->B; return curr; }
         |
         |int main() {
         |  state current = { .a=0.0, .dx=1.0, .dy=0.0, .r=1.0, .v=1.0, .w=1.0, .x=0.0, .y=0.0, .xo=10.0, .yo=0.0, .dxo=-1.0, .dyo=0.0, .t=0.0 };
         |  parameters params = { .A=1.0, .B=2.0, .V=1.0, .ep=0.05 };
         |  state input = { 0 };
         |  printf("Returned a=%1.1Lf\\n", monitoredCtrl(current, params, input, &ctrl, &fallback).a);
         |  /* jump robot ahead and speed up, now unsafe */
         |  state next = { .a=0.0, .dx=1.0, .dy=0.0, .r=1.0, .v=4.0, .w=4.0, .x=9.0, .y=0.0, .xo=10.0, .yo=0.0, .dxo=-1.0, .dyo=0.0 };
         |  printf("Returned a=%1.1Lf", monitoredCtrl(next, params, input, &ctrl, &fallback).a);
         |  return 0;
         |}
         |""".stripMargin

    val cmd = CodeGenTestTools.compileC(code)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        "Controller chooses A\nReturned a=1.0\nController chooses A\nFallback returns -B\nReturned a=-2.0"
    }
  }

  "Controller generation" should "translate a simple deterministic controller" in {
    val ctrlPrg = "x:=2;".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  prg.state.x = 2.0L; prg.success = 1;
        |  return prg.state;
        |}""".stripMargin
  }

  it should "translate a simple deterministic controller with MPFR" in {
    val ctrlPrg = "x:=2;".asProgram
    CPrettyPrinter.printer = new CMpfrPrettyPrinter()
    val cPrg = new CMpfrControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
                       |  struct { state state; int success; } prg = { .state=curr, .success=0 };
                       |  mpfr_t _t_0 /* 2.0L */;
                       |  mpfr_init2(_t_0, 200);
                       |  mpfr_set_ld(_t_0, 2L, MPFR_RNDD);
                       |  prg.state.x = mpfr_get_ld(_t_0, MPFR_RNDD);
                       |  prg.success = 1;
                       |  return prg.state;
                       |}""".stripMargin
  }

  it should "translate nested choices" in {
    val ctrlPrg = "x:=2;++x:=3;{x:=4;++x:=5;}".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  {
        |    state reset = prg.state;
        |    prg.state.x = 2.0L; prg.success = 1;
        |    if (!prg.success) prg.state = reset;
        |  }
        |  if (!prg.success) {
        |    state reset = prg.state;
        |    {
        |      prg.state.x = 3.0L; prg.success = 1;
        |    }
        |    if (prg.success) {
        |      {
        |        state reset = prg.state;
        |        prg.state.x = 4.0L; prg.success = 1;
        |        if (!prg.success) prg.state = reset;
        |      }
        |      if (!prg.success) {
        |        state reset = prg.state;
        |        prg.state.x = 5.0L; prg.success = 1;
        |        if (!prg.success) prg.state = reset;
        |      }
        |    }
        |    if (!prg.success) prg.state = reset;
        |  }
        |  return prg.state;
        |}""".stripMargin
  }

  it should "translate nested choices with MPFR" in {
    val ctrlPrg = "x:=2;++x:=3;{x:=4;++x:=5;}".asProgram
    CPrettyPrinter.printer = new CMpfrPrettyPrinter()
    val cPrg = new CMpfrControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
                       |  struct { state state; int success; } prg = { .state=curr, .success=0 };
                       |  {
                       |    state reset = prg.state;
                       |    mpfr_t _t_0 /* 2.0L */;
                       |    mpfr_init2(_t_0, 200);
                       |    mpfr_set_ld(_t_0, 2L, MPFR_RNDD);
                       |    prg.state.x = mpfr_get_ld(_t_0, MPFR_RNDD);
                       |    prg.success = 1;
                       |    if (!prg.success) prg.state = reset;
                       |  }
                       |  if (!prg.success) {
                       |    state reset = prg.state;
                       |    {
                       |      mpfr_t _t_0 /* 3.0L */;
                       |      mpfr_init2(_t_0, 200);
                       |      mpfr_set_ld(_t_0, 3L, MPFR_RNDD);
                       |      prg.state.x = mpfr_get_ld(_t_0, MPFR_RNDD);
                       |      prg.success = 1;
                       |    }
                       |    if (prg.success) {
                       |      {
                       |        state reset = prg.state;
                       |        mpfr_t _t_0 /* 4.0L */;
                       |        mpfr_init2(_t_0, 200);
                       |        mpfr_set_ld(_t_0, 4L, MPFR_RNDD);
                       |        prg.state.x = mpfr_get_ld(_t_0, MPFR_RNDD);
                       |        prg.success = 1;
                       |        if (!prg.success) prg.state = reset;
                       |      }
                       |      if (!prg.success) {
                       |        state reset = prg.state;
                       |        mpfr_t _t_0 /* 5.0L */;
                       |        mpfr_init2(_t_0, 200);
                       |        mpfr_set_ld(_t_0, 5L, MPFR_RNDD);
                       |        prg.state.x = mpfr_get_ld(_t_0, MPFR_RNDD);
                       |        prg.success = 1;
                       |        if (!prg.success) prg.state = reset;
                       |      }
                       |    }
                       |    if (!prg.success) prg.state = reset;
                       |  }
                       |  return prg.state;
                       |}""".stripMargin
  }

  it should "translate a nondeterministic assignment into an input lookup" in {
    val ctrlPrg = "x:=*;".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  prg.state.x = in->x; prg.success = 1;
        |  return prg.state;
        |}""".stripMargin
  }

  it should "translate sequential compositions, tests, and nondeterministic choices" in {
    val ctrlPrg = "x:=*;?x<=5; ++ x:=7;".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  {
        |    state reset = prg.state;
        |    {
        |      prg.state.x = in->x; prg.success = 1;
        |    }
        |    if (prg.success) {
        |      prg.success = (prg.state.x <= 5.0L);
        |    }
        |    if (!prg.success) prg.state = reset;
        |  }
        |  if (!prg.success) {
        |    state reset = prg.state;
        |    prg.state.x = 7.0L; prg.success = 1;
        |    if (!prg.success) prg.state = reset;
        |  }
        |  return prg.state;
        |}""".stripMargin
  }

  it should "translate sequential compositions, tests, and nondeterministic choices with MPFR" in {
    val ctrlPrg = "x:=*;?x<=5; ++ x:=7;".asProgram
    CPrettyPrinter.printer = new CMpfrPrettyPrinter()
    val cPrg = new CMpfrControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
                       |  struct { state state; int success; } prg = { .state=curr, .success=0 };
                       |  {
                       |    state reset = prg.state;
                       |    {
                       |      prg.state.x = in->x; prg.success = 1;
                       |    }
                       |    if (prg.success) {
                       |      mpfr_t _t_1 /* 5.0L */,
                       |  prg_state_x /* prg.state.x */;
                       |      mpfr_init2(_t_1, 200);
                       |  mpfr_init2(prg_state_x, 200);
                       |      mpfr_set_ld(_t_1, 5L, MPFR_RNDD);
                       |  mpfr_set_ld(prg_state_x, prg.state.x, MPFR_RNDD);
                       |      prg.success = mpfr_get_ld(prg_state_x, MPFR_RNDD) <= mpfr_get_ld(_t_1, MPFR_RNDD);
                       |    }
                       |    if (!prg.success) prg.state = reset;
                       |  }
                       |  if (!prg.success) {
                       |    state reset = prg.state;
                       |    mpfr_t _t_0 /* 7.0L */;
                       |    mpfr_init2(_t_0, 200);
                       |    mpfr_set_ld(_t_0, 7L, MPFR_RNDD);
                       |    prg.state.x = mpfr_get_ld(_t_0, MPFR_RNDD);
                       |    prg.success = 1;
                       |    if (!prg.success) prg.state = reset;
                       |  }
                       |  return prg.state;
                       |}""".stripMargin
  }

  it should "look up parameters" in {
    val ctrlPrg = "x:=A;".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg, Set(Variable("x")))
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  prg.state.x = params->A; prg.success = 1;
        |  return prg.state;
        |}""".stripMargin
  }

  it should "look up function parameters" in {
    val ctrlPrg = "x:=A();".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg, Set(Variable("x")))
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  prg.state.x = params->A; prg.success = 1;
        |  return prg.state;
        |}""".stripMargin
  }

  it should "skip ODEs and repeat loops until success" in {
    val ctrlPrg = "{x:=2;{x'=4}}*".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  while (!prg.success) {
        |    {
        |      prg.state.x = 2.0L; prg.success = 1;
        |    }
        |    if (prg.success) {
        |      prg.success = 1; /* done choosing actuator set values */
        |    }
        |  }
        |  return prg.state;
        |}""".stripMargin
  }

  it should "compile and run a controller" in {
    val ctrlPrg = "x:=*;?x<=A; ++ x:=7;".asProgram
    val code = (new CGenerator(new CControllerGenerator()))(ctrlPrg, Set(Variable("x")), Set(Variable("x")))

    val mainCode =
      s"""
       |#include <stdio.h>
       |${code._1}
       |${code._2}
       |
       |int main() {
       |  state current = { .x=0.0 };
       |  parameters params = { .A=1.0 };
       |  input in = { .x=0.5 };
       |  printf("Returned x=%1.1Lf\\n", ctrlStep(current, &params, &in).x);
       |  /* change input */
       |  input nextIn = { .x=2.0 };
       |  printf("Returned x=%1.1Lf", ctrlStep(current, &params, &nextIn).x);
       |  return 0;
       |}
       |""".stripMargin

    val cmd = CodeGenTestTools.compileC(mainCode)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        "Returned x=0.5\nReturned x=7.0"
    }
  }

  it should "compile and run a controller with MPFR" taggedAs IgnoreInBuildTest in {
    val ctrlPrg = "x:=*;?x<=A; ++ x:=7;".asProgram
    CPrettyPrinter.printer = new CMpfrPrettyPrinter()
    val code = (new CGenerator(new CMpfrControllerGenerator()))(ctrlPrg, Set(Variable("x")), Set(Variable("x")))

    val mainCode =
      s"""
         |#include <stdio.h>
         |#include <mpfr.h>
         |${code._1}
         |${code._2}
         |
       |int main() {
         |  state current = { .x=0.0 };
         |  parameters params = { .A=1.0 };
         |  input in = { .x=0.5 };
         |  printf("Returned x=%1.1Lf\\n", ctrlStep(current, &params, &in).x);
         |  /* change input */
         |  input nextIn = { .x=2.0 };
         |  printf("Returned x=%1.1Lf", ctrlStep(current, &params, &nextIn).x);
         |  return 0;
         |}
         |""".stripMargin

    val cmd = CodeGenTestTools.compileC(mainCode, "-lmpfr -lgmp")
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        "Returned x=0.5\nReturned x=7.0"
    }
  }

  it should "compile and run a fallback controller of a monitor" in {
    val ctrlPrg = "x:=*;?x<=A; ++ x:=7;".asProgram
    val monitor = "xpost()<=A | xpost()=7".asFormula // == controller monitor of ctrlPrg

    val stateVars = Set(Variable("x"))
    val params = Set[NamedSymbol](Variable("A"))
    val inputs = Set(Variable("x"))

    val declarations =
      CGenerator.printParameterDeclaration(params) + "\n" +
      CGenerator.printStateDeclaration(stateVars) + "\n" +
      CGenerator.printInputDeclaration(inputs)
    val fallbackCode = new CControllerGenerator()(ctrlPrg, stateVars)._2
    val monitorCode = new CMonitorGenerator()(monitor, stateVars)._1

    val code = s"""
       |#include <stdio.h>
       |${CGenerator.INCLUDE_STATEMENTS}
       |$declarations
       |$fallbackCode
       |$monitorCode
       |
       |state ctrl(state curr, const parameters* const params, const input* const in) { printf("Choosing 2*%1.1Lf", curr.x); curr.x = 2*curr.x; return curr; }
       |
       |int main() {
       |  state current = { .x=0.2 };
       |  parameters params = { .A=1.0 };
       |  long double inputSequence[5] = { 3.0, 3.0, 3.0, 1.0, 0.5 };
       |  for (int i=0; i<5; ++i) {
       |    input in = { .x=inputSequence[i] };
       |    current = monitoredCtrl(current, &params, &in, &ctrl, &ctrlStep);
       |    printf(", result x=%1.1Lf\\n", current.x);
       |  }
       |  return 0;
       |}
       |""".stripMargin

    val cmd = CodeGenTestTools.compileC(code)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        """Choosing 2*0.2, result x=0.4
          |Choosing 2*0.4, result x=0.8
          |Choosing 2*0.8, result x=7.0
          |Choosing 2*7.0, result x=1.0
          |Choosing 2*1.0, result x=0.5
          |""".stripMargin
    }
  }

  it should "execute nondeterministic choices in a fallback controller with correct reset" in {
    val ctrlPrg = "x:=1; { {x:=2;?x<=1;} ++ {x:=3;?x<=1;} }".asProgram
    val monitor = "xpost()<=A | xpost()=7".asFormula // == controller monitor of ctrlPrg

    val stateVars = Set(Variable("x"))
    val params = Set[NamedSymbol](Variable("A"))

    val declarations =
      CGenerator.printParameterDeclaration(params) + "\n" +
        CGenerator.printStateDeclaration(stateVars) + "\n" +
        CGenerator.printInputDeclaration(Set())
    val fallbackCode = new CControllerGenerator()(ctrlPrg, stateVars)._2
    val monitorCode = new CMonitorGenerator()(monitor, stateVars)._1

    val code = s"""
      |#include <stdio.h>
      |${CGenerator.INCLUDE_STATEMENTS}
      |$declarations
      |$fallbackCode
      |$monitorCode
      |
      |state ctrl(state curr, const parameters* const params, const input* const in) { printf("Choosing 2"); curr.x = 2.0L; return curr; }
      |
      |int main() {
      |  state current = { .x=0.2 };
      |  parameters params = { .A=1.0 };
      |  current = monitoredCtrl(current, &params, 0, &ctrl, &ctrlStep);
      |  printf(", result x=%1.1Lf\\n", current.x);
      |  return 0;
      |}
      |""".stripMargin

    compileAndRun(code, "Choosing 2, result x=1.0\n")
  }

  "Deterministic controller generator" should "compile deterministic simple program" in {
    val ctrlPrg = "y:=*; if (y<=1) { x:=2; } else { x:=3; }".asProgram

    val stateVars = Set(Variable("x"), Variable("y"))

    val declarations =
      CGenerator.printParameterDeclaration(Set()) + "\n" +
      CGenerator.printStateDeclaration(stateVars) + "\n" +
      CGenerator.printInputDeclaration(Set(Variable("y")))
    val ctrlCode = new CDetControllerGenerator()(ctrlPrg, stateVars)._2

    ctrlCode shouldBe
      """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  curr.y = in->y;
        |  if (curr.y <= 1.0L) {
        |    curr.x = 2.0L;
        |  } else {
        |    curr.x = 3.0L;
        |  }
        |  return curr;
        |}""".stripMargin

    def code(y: String) = s"""
      |#include <stdio.h>
      |${CGenerator.INCLUDE_STATEMENTS}
      |$declarations
      |$ctrlCode
      |
      |
      |int main() {
      |  state current = { .x=0.2L };
      |  input in = { .y=$y };
      |  current = ctrlStep(current, 0, &in);
      |  printf("Result x=%1.1Lf\\n", current.x);
      |  return 0;
      |}
      |""".stripMargin

    compileAndRun(code("1.0L"), "Result x=2.0\n")
    compileAndRun(code("5.0L"), "Result x=3.0\n")
  }

  it should "compile standalone if" in {
    val program = "if (x>=5) { y:=2; }".asProgram
    val stateVars = Set(Variable("x"), Variable("y"))
    new CDetControllerGenerator()(program, stateVars)._2 shouldBe
      """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  if (params->x >= 5.0L) {
        |    curr.y = 2.0L;
        |  }
        |  return curr;
        |}""".stripMargin
  }

  private def compileAndRun(code: String, expected: String) = {
    val cmd = CodeGenTestTools.compileC(code)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe expected
    }
  }
}
