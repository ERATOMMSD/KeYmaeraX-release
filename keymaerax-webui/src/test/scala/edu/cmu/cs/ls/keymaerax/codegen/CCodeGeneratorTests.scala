package edu.cmu.cs.ls.keymaerax.codegen

/**
* Copyright (c) Carnegie Mellon University.
* See LICENSE.txt for the conditions of this license.
*/

import java.io.{File, FileWriter}

import edu.cmu.cs.ls.keymaerax.core.Variable
import edu.cmu.cs.ls.keymaerax.parser.KeYmaeraXParser
import edu.cmu.cs.ls.keymaerax.launcher.KeYmaeraX
import edu.cmu.cs.ls.keymaerax.parser.StringConverter._
import org.scalatest.{FlatSpec, Matchers}
import testHelper.KeYmaeraXTestTags.IgnoreInBuildTest

/**
 * Tests the C++ ModelPlex code generator.
 * @author Ran Ji
 * @author Stefan Mitsch
 */
class CCodeGeneratorTests extends FlatSpec with Matchers {

  // terms

  "numbers" should "compile floating point" in {
    CGenerator("2+1.5>3.25".asFormula) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |/* monitor */
        |bool monitor () {
        |  return (((2)) + ((1.5)))>((3.25));
        |}
        |
        |""".stripMargin
  }

  it should "compile large number" in {
    CGenerator("9223372036854775807>1".asFormula) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |/* monitor */
        |bool monitor () {
        |  return ((9223372036854775807))>((1));
        |}
        |
        |""".stripMargin
  }

  it should "throw exception for too large number" in {
    a [CodeGenerationException] should be thrownBy CGenerator("92233720368547758079>1".asFormula)
  }

  "variables" should "compile with index" in {
    CGenerator("x*z-y_1>1".asFormula, List(Variable("x"))) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double y_1;
        |  long double z;
        |} parameters;
        |
        |typedef struct state {
        |  long double x;
        |} state;
        |
        |/* monitor */
        |bool monitor (state& curr, parameters& params) {
        |  static state pre = curr;
        |  int result = (((pre.x)*(params.z)) - (params.y_1))>((1));
        |  pre = curr;
        |  return result;
        |}
        |
        |""".stripMargin
  }

  "nullary functions" should "compile to parameters" in {
    CGenerator("x()>1".asFormula) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double x;
        |} parameters;
        |
        |/* monitor */
        |bool monitor (parameters& params) {
        |  return (params.x)>((1));
        |}
        |
        |""".stripMargin
  }

  "power" should "compile int exp" in {
    CGenerator("x^3>1".asFormula) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double x;
        |} parameters;
        |
        |/* monitor */
        |bool monitor (parameters& params) {
        |  return (((params.x)*(params.x)*(params.x)))>((1));
        |}
        |
        |""".stripMargin
  }

  it should "compile neg int exp" in {
    CGenerator("(x+y)^-3>1".asFormula) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double x;
        |  long double y;
        |} parameters;
        |
        |/* monitor */
        |bool monitor (parameters& params) {
        |  return ((1.0/(((params.x) + (params.y))*((params.x) + (params.y))*((params.x) + (params.y)))))>((1));
        |}
        |
        |""".stripMargin
  }

  it should "compile any exp" in {
    CGenerator("x^y>1".asFormula) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double x;
        |  long double y;
        |} parameters;
        |
        |/* monitor */
        |bool monitor (parameters& params) {
        |  return ((pow((params.x),(params.y))))>((1));
        |}
        |
        |""".stripMargin
  }

  "abs" should "compile" in {
    CGenerator("abs(x-y)>0".asFormula) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double x;
        |  long double y;
        |} parameters;
        |
        |/* monitor */
        |bool monitor (parameters& params) {
        |  return (fabsl((params.x) - (params.y)))>((0));
        |}
        |
        |""".stripMargin
  }

  "min" should "compile" in {
    CGenerator("min(x,y)<=x".asFormula) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double x;
        |  long double y;
        |} parameters;
        |
        |/* monitor */
        |bool monitor (parameters& params) {
        |  return (fminl(params.x, params.y))<=(params.x);
        |}
        |
        |""".stripMargin
  }

  "max" should "compile" in {
    CGenerator("max(x,y)>=x".asFormula) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double x;
        |  long double y;
        |} parameters;
        |
        |/* monitor */
        |bool monitor (parameters& params) {
        |  return (fmaxl(params.x, params.y))>=(params.x);
        |}
        |
        |""".stripMargin
  }

  "C generator" should "compile function with 2 parameters" ignore {
    CGenerator("f(x,y)>g(y,z)".asFormula) should be("/**************************\n * Generated by KeYmaera X\n **************************/\n\n" +
      "#include <math.h>\n#include <stdbool.h>\n\n" +
      "/* function declaration */\nlong double f(long double, long double);\nlong double g(long double, long double);\nlong double x();\nlong double y();\nlong double z();\n\n" +
      "/* monitor */\nbool monitor () {\n  return (f(x(), y()))>(g(y(), z()));\n}\n\n")
  }

  it should "compile function with more parameters" ignore {
    CGenerator("f(x,y,z)>0".asFormula) should be("/**************************\n * Generated by KeYmaera X\n **************************/\n\n" +
      "#include <math.h>\n#include <stdbool.h>\n\n" +
      "/* function declaration */\nlong double f(long double, long double, long double);\nlong double x();\nlong double y();\nlong double z();\n\n" +
      "/* monitor */\nbool monitor () {\n  return (f(x(), y(), z()))>((0));\n}\n\n")
  }


  // hacms case studies

  "robix" should "generate C code for passivesafety" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafety.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    CGenerator(monitorExp, List(Variable("a"),Variable("w"),Variable("r"),Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double A;
        |  long double B;
        |  long double V;
        |  long double ep;
        |  long double v;
        |  long double x;
        |  long double y;
        |} parameters;
        |
        |typedef struct state {
        |  long double a;
        |  long double dxo;
        |  long double dyo;
        |  long double r;
        |  long double t;
        |  long double w;
        |  long double xo;
        |  long double yo;
        |} state;
        |
        |/* monitor */
        |bool monitor (state& curr, parameters& params) {
        |  static state pre = curr;
        |  int result = (((((curr.dxo)*(curr.dxo))) + (((curr.dyo)*(curr.dyo))))<=(((params.V)*(params.V))))&&((((curr.a)==(-(params.B)))&&(((curr.w)==(pre.w))&&(((curr.r)==(pre.r))&&(((curr.xo)==(pre.xo))&&(((curr.yo)==(pre.yo))&&(((curr.dxo)==(curr.dxo))&&(((curr.dyo)==(curr.dyo))&&((curr.t)==((0))))))))))||((((params.v)==((0)))&&(((curr.a)==((0)))&&(((curr.w)==((0)))&&(((curr.r)==(pre.r))&&(((curr.xo)==(pre.xo))&&(((curr.yo)==(pre.yo))&&(((curr.dxo)==(curr.dxo))&&(((curr.dyo)==(curr.dyo))&&((curr.t)==((0)))))))))))||(((-(params.B))<=(curr.a))&&(((curr.a)<=(params.A))&&(((curr.r)!=((0)))&&((((curr.w)*(curr.r))==(params.v))&&(((((!(((params.x) - (curr.xo))>=((0))))||(((params.x) - (curr.xo))>((((((params.v)*(params.v)))/(((2))*(params.B))) + (((params.V)*(params.v))/(params.B))) + ((((params.A)/(params.B)) + ((1)))*((((params.A)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((params.v) + (params.V))))))))&&((!(((params.x) - (curr.xo))<=((0))))||(((curr.xo) - (params.x))>((((((params.v)*(params.v)))/(((2))*(params.B))) + (((params.V)*(params.v))/(params.B))) + ((((params.A)/(params.B)) + ((1)))*((((params.A)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((params.v) + (params.V)))))))))||(((!(((params.y) - (curr.yo))>=((0))))||(((params.y) - (curr.yo))>((((((params.v)*(params.v)))/(((2))*(params.B))) + (((params.V)*(params.v))/(params.B))) + ((((params.A)/(params.B)) + ((1)))*((((params.A)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((params.v) + (params.V))))))))&&((!(((params.y) - (curr.yo))<=((0))))||(((curr.yo) - (params.y))>((((((params.v)*(params.v)))/(((2))*(params.B))) + (((params.V)*(params.v))/(params.B))) + ((((params.A)/(params.B)) + ((1)))*((((params.A)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((params.v) + (params.V))))))))))&&(((curr.a)==(curr.a))&&(((curr.w)==(curr.w))&&(((curr.r)==(curr.r))&&(((curr.xo)==(curr.xo))&&(((curr.yo)==(curr.yo))&&(((curr.dxo)==(curr.dxo))&&(((curr.dyo)==(curr.dyo))&&((curr.t)==((0)))))))))))))))));
        |  pre = curr;
        |  return result;
        |}
        |
        |""".stripMargin
    }

  it should "generate C code for passivesafety_renamed" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafety_renamed.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    CGenerator(monitorExp, List(Variable("a"),Variable("om"),Variable("r"),Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double A;
        |  long double B;
        |  long double Vo;
        |  long double ep;
        |  long double v;
        |  long double x;
        |  long double y;
        |} parameters;
        |
        |typedef struct state {
        |  long double a;
        |  long double dxo;
        |  long double dyo;
        |  long double om;
        |  long double r;
        |  long double t;
        |  long double xo;
        |  long double yo;
        |} state;
        |
        |/* monitor */
        |bool monitor (state& curr, parameters& params) {
        |  static state pre = curr;
        |  int result = (((((curr.dxo)*(curr.dxo))) + (((curr.dyo)*(curr.dyo))))<=(((params.Vo)*(params.Vo))))&&((((curr.a)==(-(params.B)))&&(((curr.om)==(pre.om))&&(((curr.r)==(pre.r))&&(((curr.xo)==(pre.xo))&&(((curr.yo)==(pre.yo))&&(((curr.dxo)==(curr.dxo))&&(((curr.dyo)==(curr.dyo))&&((curr.t)==((0))))))))))||((((params.v)==((0)))&&(((curr.a)==((0)))&&(((curr.om)==((0)))&&(((curr.r)==(pre.r))&&(((curr.xo)==(pre.xo))&&(((curr.yo)==(pre.yo))&&(((curr.dxo)==(curr.dxo))&&(((curr.dyo)==(curr.dyo))&&((curr.t)==((0)))))))))))||(((-(params.B))<=(curr.a))&&(((curr.a)<=(params.A))&&(((curr.r)!=((0)))&&((((curr.om)*(curr.r))==(params.v))&&(((((!(((params.x) - (curr.xo))>=((0))))||(((params.x) - (curr.xo))>((((((params.v)*(params.v)))/(((2))*(params.B))) + (((params.Vo)*(params.v))/(params.B))) + ((((params.A)/(params.B)) + ((1)))*((((params.A)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((params.v) + (params.Vo))))))))&&((!(((params.x) - (curr.xo))<=((0))))||(((curr.xo) - (params.x))>((((((params.v)*(params.v)))/(((2))*(params.B))) + (((params.Vo)*(params.v))/(params.B))) + ((((params.A)/(params.B)) + ((1)))*((((params.A)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((params.v) + (params.Vo)))))))))||(((!(((params.y) - (curr.yo))>=((0))))||(((params.y) - (curr.yo))>((((((params.v)*(params.v)))/(((2))*(params.B))) + (((params.Vo)*(params.v))/(params.B))) + ((((params.A)/(params.B)) + ((1)))*((((params.A)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((params.v) + (params.Vo))))))))&&((!(((params.y) - (curr.yo))<=((0))))||(((curr.yo) - (params.y))>((((((params.v)*(params.v)))/(((2))*(params.B))) + (((params.Vo)*(params.v))/(params.B))) + ((((params.A)/(params.B)) + ((1)))*((((params.A)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((params.v) + (params.Vo))))))))))&&(((curr.a)==(curr.a))&&(((curr.om)==(curr.om))&&(((curr.r)==(curr.r))&&(((curr.xo)==(curr.xo))&&(((curr.yo)==(curr.yo))&&(((curr.dxo)==(curr.dxo))&&(((curr.dyo)==(curr.dyo))&&((curr.t)==((0)))))))))))))))));
        |  pre = curr;
        |  return result;
        |}
        |
        |""".stripMargin
  }

  it should "generate C code for passivesafetyabs" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val vars =
      List(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    CGenerator(monitorExp, vars) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double A;
        |  long double B;
        |  long double V;
        |  long double ep;
        |} parameters;
        |
        |typedef struct state {
        |  long double a;
        |  long double dx;
        |  long double dxo;
        |  long double dy;
        |  long double dyo;
        |  long double r;
        |  long double t;
        |  long double v;
        |  long double w;
        |  long double x;
        |  long double xo;
        |  long double y;
        |  long double yo;
        |} state;
        |
        |/* monitor */
        |bool monitor (state& curr, parameters& params) {
        |  static state pre = curr;
        |  int result = (((((curr.dxo)*(curr.dxo))) + (((curr.dyo)*(curr.dyo))))<=(((params.V)*(params.V))))&&((((((0))<=(params.ep))&&((pre.v)>=((0))))&&((((((((((((((curr.xo)==(pre.xo))&&((curr.yo)==(pre.yo)))&&((curr.dxo)==(curr.dxo)))&&((curr.dyo)==(curr.dyo)))&&((curr.x)==(pre.x)))&&((curr.y)==(pre.y)))&&((curr.dx)==(pre.dx)))&&((curr.dy)==(pre.dy)))&&((curr.v)==(pre.v)))&&((curr.w)==(pre.w)))&&((curr.a)==(-(params.B))))&&((curr.r)==(pre.r)))&&((curr.t)==((0)))))||((((pre.v)==((0)))&&(((((0))<=(params.ep))&&((pre.v)>=((0))))&&((((((((((((((curr.xo)==(pre.xo))&&((curr.yo)==(pre.yo)))&&((curr.dxo)==(curr.dxo)))&&((curr.dyo)==(curr.dyo)))&&((curr.x)==(pre.x)))&&((curr.y)==(pre.y)))&&((curr.dx)==(pre.dx)))&&((curr.dy)==(pre.dy)))&&((curr.v)==(pre.v)))&&((curr.w)==((0))))&&((curr.a)==((0))))&&((curr.r)==(pre.r)))&&((curr.t)==((0))))))||((((-(params.B))<=(curr.a))&&((curr.a)<=(params.A)))&&(((curr.r)!=((0)))&&((((curr.w)*(curr.r))==(pre.v))&&((((fabsl((pre.x) - (curr.xo)))>((((((pre.v)*(pre.v)))/(((2))*(params.B))) + (((params.V)*(pre.v))/(params.B))) + ((((params.A)/(params.B)) + ((1)))*((((params.A)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((pre.v) + (params.V)))))))||((fabsl((pre.y) - (curr.yo)))>((((((pre.v)*(pre.v)))/(((2))*(params.B))) + (((params.V)*(pre.v))/(params.B))) + ((((params.A)/(params.B)) + ((1)))*((((params.A)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((pre.v) + (params.V))))))))&&(((((0))<=(params.ep))&&((pre.v)>=((0))))&&((((((((((((((curr.xo)==(curr.xo))&&((curr.yo)==(curr.yo)))&&((curr.dxo)==(curr.dxo)))&&((curr.dyo)==(curr.dyo)))&&((curr.x)==(pre.x)))&&((curr.y)==(pre.y)))&&((curr.dx)==(pre.dx)))&&((curr.dy)==(pre.dy)))&&((curr.v)==(pre.v)))&&((curr.w)==(curr.w)))&&((curr.a)==(curr.a)))&&((curr.r)==(curr.r)))&&((curr.t)==((0)))))))))));
        |  pre = curr;
        |  return result;
        |}
        |
        |""".stripMargin
  }

  it should "generate C code for passivesafetyabs with KeYmaeraX command line interface" taggedAs IgnoreInBuildTest in {
    // command line main has to initialize the prover itself, so dispose all test setup first
//    afterEach()

    val inputFileName = "./keymaerax-webui/src/test/resources/examples/casestudies/robix/passivesafetyabs.kym"
    val outputFileName = File.createTempFile("passivesafetyabs", ".c").getAbsolutePath

    KeYmaeraX.main(Array("-codegen", inputFileName, "-vars", "a,w,r,xo,yo,dxo,dyo", "-nointerval", "-out", outputFileName))

    val expectedCCode = scala.io.Source.fromFile("./keymaerax-webui/src/test/resources/examples/casestudies/robix/passivesafetyabs.c").mkString
    val actualFileContent = scala.io.Source.fromFile(outputFileName).mkString

    actualFileContent should include (expectedCCode)
  }

  it should "generate C code for passiveorientationsafety" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passiveorientationsafety.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    CGenerator(monitorExp,
      List(Variable("a"), Variable("w"), Variable("dx"), Variable("dy"), Variable("r"), Variable("t"), Variable("ox"),
           Variable("oy"), Variable("odx"), Variable("ody"), Variable("isVisible"), Variable("talpha"))) shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double A;
        |  long double V;
        |  long double alpha;
        |  long double b;
        |  long double ep;
        |  long double v;
        |  long double x;
        |  long double y;
        |} parameters;
        |
        |typedef struct state {
        |  long double a;
        |  long double dx;
        |  long double dy;
        |  long double isVisible;
        |  long double odx;
        |  long double ody;
        |  long double ox;
        |  long double oy;
        |  long double r;
        |  long double t;
        |  long double talpha;
        |  long double w;
        |} state;
        |
        |/* monitor */
        |bool monitor (state& curr, parameters& params) {
        |  static state pre = curr;
        |  int result = (((((curr.odx)*(curr.odx))) + (((curr.ody)*(curr.ody))))<=(((params.V)*(params.V))))&&(((((curr.w)*(pre.r))==(params.v))&&(((curr.a)==(-(params.b)))&&(((curr.w)==(curr.w))&&(((curr.dx)==(pre.dx))&&(((curr.dy)==(pre.dy))&&(((curr.r)==(pre.r))&&(((curr.t)==((0)))&&(((curr.ox)==(pre.ox))&&(((curr.oy)==(pre.oy))&&(((curr.odx)==(curr.odx))&&(((curr.ody)==(curr.ody))&&(((curr.isVisible)==(pre.isVisible))&&((curr.talpha)==(pre.talpha))))))))))))))||((((params.v)==((0)))&&((((curr.w)*(pre.r))==(params.v))&&(((curr.a)==((0)))&&(((curr.w)==(curr.w))&&(((curr.dx)==(-(pre.dx)))&&(((curr.dy)==(-(pre.dy)))&&(((curr.r)==(pre.r))&&(((curr.t)==((0)))&&(((curr.ox)==(pre.ox))&&(((curr.oy)==(pre.oy))&&(((curr.odx)==(curr.odx))&&(((curr.ody)==(curr.ody))&&(((curr.isVisible)==(pre.isVisible))&&((curr.talpha)==(pre.talpha)))))))))))))))||(((-(params.b))<=(curr.a))&&(((curr.a)<=(params.A))&&(((curr.r)!=((0)))&&(((((params.v) + ((curr.a)*(params.ep)))<((0)))&&((((curr.isVisible)<((0)))||((((!(((params.x) - (curr.ox))>=((0))))||(((params.x) - (curr.ox))>(((((params.v)*(params.v)))/(((-2))*(curr.a))) + ((params.V)*((params.v)/(-(curr.a)))))))&&((!(((params.x) - (curr.ox))<=((0))))||(((curr.ox) - (params.x))>(((((params.v)*(params.v)))/(((-2))*(curr.a))) + ((params.V)*((params.v)/(-(curr.a))))))))||(((!(((params.y) - (curr.oy))>=((0))))||(((params.y) - (curr.oy))>(((((params.v)*(params.v)))/(((-2))*(curr.a))) + ((params.V)*((params.v)/(-(curr.a)))))))&&((!(((params.y) - (curr.oy))<=((0))))||(((curr.oy) - (params.y))>(((((params.v)*(params.v)))/(((-2))*(curr.a))) + ((params.V)*((params.v)/(-(curr.a))))))))))&&(((!((curr.r)>=((0))))||(((((params.v)*(params.v)))/(((-2))*(curr.a)))<((params.alpha)*(curr.r))))&&(((!((curr.r)<((0))))||(((((params.v)*(params.v)))/(((-2))*(curr.a)))<(-((params.alpha)*(curr.r)))))&&((((curr.w)*(curr.r))==(params.v))&&(((curr.a)==(curr.a))&&(((curr.w)==(curr.w))&&(((curr.dx)==(pre.dx))&&(((curr.dy)==(pre.dy))&&(((curr.r)==(curr.r))&&(((curr.t)==((0)))&&(((curr.ox)==(curr.ox))&&(((curr.oy)==(curr.oy))&&(((curr.odx)==(curr.odx))&&(((curr.ody)==(curr.ody))&&(((curr.isVisible)==(curr.isVisible))&&((curr.talpha)==((0)))))))))))))))))))||((((params.v) + ((curr.a)*(params.ep)))>=((0)))&&((((curr.isVisible)<((0)))||((((!(((params.x) - (curr.ox))>=((0))))||(((params.x) - (curr.ox))>((((((params.v)*(params.v)))/(((2))*(params.b))) + ((params.V)*((params.v)/(params.b)))) + ((((curr.a)/(params.b)) + ((1)))*((((curr.a)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((params.v) + (params.V))))))))&&((!(((params.x) - (curr.ox))<=((0))))||(((curr.ox) - (params.x))>((((((params.v)*(params.v)))/(((2))*(params.b))) + ((params.V)*((params.v)/(params.b)))) + ((((curr.a)/(params.b)) + ((1)))*((((curr.a)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((params.v) + (params.V)))))))))||(((!(((params.y) - (curr.oy))>=((0))))||(((params.y) - (curr.oy))>((((((params.v)*(params.v)))/(((2))*(params.b))) + ((params.V)*((params.v)/(params.b)))) + ((((curr.a)/(params.b)) + ((1)))*((((curr.a)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((params.v) + (params.V))))))))&&((!(((params.y) - (curr.oy))<=((0))))||(((curr.oy) - (params.y))>((((((params.v)*(params.v)))/(((2))*(params.b))) + ((params.V)*((params.v)/(params.b)))) + ((((curr.a)/(params.b)) + ((1)))*((((curr.a)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*((params.v) + (params.V)))))))))))&&(((!((curr.r)>=((0))))||((((((params.v)*(params.v)))/(((2))*(params.b))) + ((((curr.a)/(params.b)) + ((1)))*((((curr.a)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*(params.v)))))<((params.alpha)*(curr.r))))&&(((!((curr.r)<((0))))||((((((params.v)*(params.v)))/(((2))*(params.b))) + ((((curr.a)/(params.b)) + ((1)))*((((curr.a)/((2)))*(((params.ep)*(params.ep)))) + ((params.ep)*(params.v)))))<(-((params.alpha)*(curr.r)))))&&((((curr.w)*(curr.r))==(params.v))&&(((curr.a)==(curr.a))&&(((curr.w)==(curr.w))&&(((curr.dx)==(pre.dx))&&(((curr.dy)==(pre.dy))&&(((curr.r)==(curr.r))&&(((curr.t)==((0)))&&(((curr.ox)==(curr.ox))&&(((curr.oy)==(curr.oy))&&(((curr.odx)==(curr.odx))&&(((curr.ody)==(curr.ody))&&(((curr.isVisible)==(curr.isVisible))&&((curr.talpha)==((0)))))))))))))))))))))))));
        |  pre = curr;
        |  return result;
        |}
        |
        |""".stripMargin
  }

  "quadcopter" should "generate C code for hybridquadrotor" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/quadcopter/hybridquadrotor.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val code = CGenerator(monitorExp, List(Variable("href")))
    code shouldBe
      """/**************************
        | *
        | * Generated by KeYmaera X
        | **************************/
        |
        |#include <math.h>
        |#include <stdbool.h>
        |
        |typedef struct parameters {
        |  long double h;
        |  long double kd;
        |  long double kp;
        |  long double sqrkp;
        |  long double v;
        |  long double y;
        |} parameters;
        |
        |typedef struct state {
        |  long double href;
        |} state;
        |
        |/* monitor */
        |bool monitor (state& curr, parameters& params) {
        |  static state pre = curr;
        |  int result = ((params.h)>=(curr.href))&&(((curr.href)>((0)))&&(((((((params.kp)<((0)))&&(((params.v)==((0)))&&((curr.href)>=(params.h))))||((((params.kp)<((0)))&&(((params.v)>((0)))&&(((((((2))*(params.h))*(params.kp)) + ((params.v)*((params.kd) + (params.y))))==((((2))*(curr.href))*(params.kp)))&&(((params.h)*(params.y))>(((params.h)*(params.kd)) + (((2))*(params.v)))))))||((((params.kp)<((0)))&&(((params.v)<((0)))&&(((((((2))*(curr.href))*(params.kp)) + ((params.v)*(params.y)))==(((((2))*(params.h))*(params.kp)) + ((params.kd)*(params.v))))&&(((((2))*(params.v)) + ((params.h)*((params.kd) + (params.y))))>((0))))))||((((params.kp)>((0)))&&(((params.v)==((0)))&&((curr.href)==(params.h))))||((((params.kp)>((0)))&&(((params.v)>((0)))&&((((((((2))*(params.h))*(params.kp)) + ((params.v)*((params.kd) + (params.y))))==((((2))*(curr.href))*(params.kp)))&&((((params.h)*(params.y))>(((params.h)*(params.kd)) + (((2))*(params.v))))&&(((params.kd) + (((2))*(params.sqrkp)))<=((0)))))||((((((((2))*(params.h))*(params.kp)) + ((params.v)*((params.kd) + (params.y))))==((((2))*(curr.href))*(params.kp)))&&((((params.kd) + (((2))*(params.sqrkp)))<((0)))&&(((((2))*(params.v)) + ((params.h)*((params.kd) + (params.y))))<((0)))))||((((((((2))*(curr.href))*(params.kp)) + ((params.v)*(params.y)))==(((((2))*(params.h))*(params.kp)) + ((params.kd)*(params.v))))&&((((params.kd) + (((2))*(params.sqrkp)))<((0)))&&(((((2))*(params.v)) + ((params.h)*((params.kd) + (params.y))))<((0)))))||(((((((2))*(params.h))*(params.kp)) + ((params.v)*((params.kd) + (params.y))))==((((2))*(curr.href))*(params.kp)))&&(((params.kd)>(((2))*(params.sqrkp)))&&((((((2))*(params.v)) + ((params.h)*((params.kd) + (params.y))))>((0)))&&(((params.h)*(params.y))>=(((params.h)*(params.kd)) + (((2))*(params.v))))))))))))||(((params.kp)>((0)))&&(((params.v)<((0)))&&((((((((2))*(params.h))*(params.kp)) + ((params.v)*((params.kd) + (params.y))))==((((2))*(curr.href))*(params.kp)))&&(((params.kd)>(((2))*(params.sqrkp)))&&(((params.h)*(params.y))<(((params.h)*(params.kd)) + (((2))*(params.v))))))||((((((((2))*(curr.href))*(params.kp)) + ((params.v)*(params.y)))==(((((2))*(params.h))*(params.kp)) + ((params.kd)*(params.v))))&&(((params.kd)>=(((2))*(params.sqrkp)))&&(((params.h)*(params.y))<(((params.h)*(params.kd)) + (((2))*(params.v))))))||((((((((2))*(curr.href))*(params.kp)) + ((params.v)*(params.y)))==(((((2))*(params.h))*(params.kp)) + ((params.kd)*(params.v))))&&(((params.kd)>(((2))*(params.sqrkp)))&&((((((2))*(params.v)) + ((params.h)*((params.kd) + (params.y))))>((0)))&&(((params.h)*(params.y))>=(((params.h)*(params.kd)) + (((2))*(params.v)))))))||(((((((2))*(curr.href))*(params.kp)) + ((params.v)*(params.y)))==(((((2))*(params.h))*(params.kp)) + ((params.kd)*(params.v))))&&((((params.h)*(params.y))>(((params.h)*(params.kd)) + (((2))*(params.v))))&&((((((2))*(params.v)) + ((params.h)*((params.kd) + (params.y))))>=((0)))&&(((params.kd) + (((2))*(params.sqrkp)))<((0))))))))))))))))&&((((((params.y)*(params.y)))==((((params.kd)*(params.kd))) - (((4))*(params.kp))))&&((params.y)>=((0))))&&((((((params.sqrkp)*(params.sqrkp)))==(params.kp))&&((params.sqrkp)>=((0))))&&((((((((((params.h)*(params.h)))*(((params.kp)*(params.kp)))) - (((((2))*(params.h))*(curr.href))*(((params.kp)*(params.kp))))) + ((((curr.href)*(curr.href)))*(((params.kp)*(params.kp))))) + ((((params.h)*(params.kd))*(params.kp))*(params.v))) - ((((curr.href)*(params.kd))*(params.kp))*(params.v))) + ((params.kp)*(((params.v)*(params.v)))))!=((0))))))||(((((params.kp)<((0)))&&(((params.v)==((0)))&&((((params.h)*(params.y))<=((params.h)*(params.kd)))||((((params.h)*((params.kd) + (params.y)))<=((0)))||((params.h)>(curr.href))))))||((((params.kp)<((0)))&&(((params.v)<((0)))&&((((params.h)*(params.y))<=(((params.h)*(params.kd)) + (((2))*(params.v))))||((((((2))*(params.v)) + ((params.h)*((params.kd) + (params.y))))<=((0)))||((((((2))*(params.h))*(params.kp)) + ((params.kd)*(params.v)))!=(((((2))*(curr.href))*(params.kp)) + ((params.v)*(params.y))))))))||((((params.kp)<((0)))&&(((params.v)>((0)))&&((((params.h)*(params.y))<=(((params.h)*(params.kd)) + (((2))*(params.v))))||((((((2))*(params.v)) + ((params.h)*((params.kd) + (params.y))))<=((0)))||((((((2))*(params.h))*(params.kp)) + ((params.v)*((params.kd) + (params.y))))!=((((2))*(curr.href))*(params.kp)))))))||((((params.kp)>((0)))&&(((params.v)==((0)))&&((((params.h)!=(curr.href))&&((((params.kd)>=(((2))*(params.sqrkp)))&&(((params.h)*(params.y))>=((params.h)*(params.kd))))||((((params.h)*((params.kd) + (params.y)))>=((0)))&&(((params.kd) + (((2))*(params.sqrkp)))<((0))))))||((((params.kd)==(((2))*(params.sqrkp)))&&(((params.h)*(params.y))>=((params.h)*(params.kd))))||((((params.kd)<(((2))*(params.sqrkp)))&&(((params.kd) + (((2))*(params.sqrkp)))>((0))))||(((params.h)>(curr.href))||((((params.kd)>(((2))*(params.sqrkp)))&&(((params.h)*((params.kd) + (params.y)))<=((0))))||((((params.kd) + (((2))*(params.sqrkp)))<=((0)))&&(((params.h)*(params.y))<=((params.h)*(params.kd)))))))))))||((((params.kp)>((0)))&&(((params.v)<((0)))&&((((((((2))*(curr.href))*(params.kp)) + ((params.v)*(params.y)))!=(((((2))*(params.h))*(params.kp)) + ((params.kd)*(params.v))))&&((((params.h)*(params.y))>=(((params.h)*(params.kd)) + (((2))*(params.v))))||((params.kd)<=(((2))*(params.sqrkp)))))||(((params.kd)<(((2))*(params.sqrkp)))||((((params.kd)>(((2))*(params.sqrkp)))&&(((((params.h)*(params.y))<(((params.h)*(params.kd)) + (((2))*(params.v))))&&((((((((2))*(curr.href))*(params.kp)) + ((params.v)*(params.y)))<(((((2))*(params.h))*(params.kp)) + ((params.kd)*(params.v))))&&((((((2))*(params.h))*(params.kp)) + ((params.v)*((params.kd) + (params.y))))<((((2))*(curr.href))*(params.kp))))||(((((((2))*(curr.href))*(params.kp)) + ((params.v)*(params.y)))>(((((2))*(params.h))*(params.kp)) + ((params.kd)*(params.v))))||((((((2))*(params.h))*(params.kp)) + ((params.v)*((params.kd) + (params.y))))>((((2))*(curr.href))*(params.kp))))))||(((((2))*(params.v)) + ((params.h)*((params.kd) + (params.y))))<=((0)))))||(((((params.h)*(params.y))>=(((params.h)*(params.kd)) + (((2))*(params.v))))&&((params.kd)<=(((2))*(params.sqrkp))))||(((params.kd) + (((2))*(params.sqrkp)))<=((0)))))))))||(((params.kp)>((0)))&&(((params.v)>((0)))&&((((((((2))*(params.h))*(params.kp)) + ((params.v)*((params.kd) + (params.y))))!=((((2))*(curr.href))*(params.kp)))&&((((params.kd) + (((2))*(params.sqrkp)))>=((0)))||(((((2))*(params.v)) + ((params.h)*((params.kd) + (params.y))))>=((0)))))||(((params.kd)>=(((2))*(params.sqrkp)))||(((((params.kd) + (((2))*(params.sqrkp)))<((0)))&&((((((2))*(params.v)) + ((params.h)*((params.kd) + (params.y))))<((0)))&&(((((((2))*(curr.href))*(params.kp)) + ((params.v)*(params.y)))<(((((2))*(params.h))*(params.kp)) + ((params.kd)*(params.v))))||(((((((2))*(params.h))*(params.kp)) + ((params.v)*((params.kd) + (params.y))))<((((2))*(curr.href))*(params.kp)))||(((((((2))*(curr.href))*(params.kp)) + ((params.v)*(params.y)))>(((((2))*(params.h))*(params.kp)) + ((params.kd)*(params.v))))&&((((((2))*(params.h))*(params.kp)) + ((params.v)*((params.kd) + (params.y))))>((((2))*(curr.href))*(params.kp))))))))||((((params.kd) + (((2))*(params.sqrkp)))>((0)))||(((params.h)*(params.y))<=(((params.h)*(params.kd)) + (((2))*(params.v)))))))))))))))&&(((((params.y)*(params.y)))==((((params.kd)*(params.kd))) - (((4))*(params.kp))))&&(((params.y)>=((0)))&&(((((params.sqrkp)*(params.sqrkp)))==(params.kp))&&(((params.sqrkp)>=((0)))&&((((((((((params.h)*(params.h)))*(((params.kp)*(params.kp)))) - (((((2))*(params.h))*(curr.href))*(((params.kp)*(params.kp))))) + ((((curr.href)*(curr.href)))*(((params.kp)*(params.kp))))) + ((((params.h)*(params.kd))*(params.kp))*(params.v))) - ((((curr.href)*(params.kd))*(params.kp))*(params.v))) + ((params.kp)*(((params.v)*(params.v)))))==((0)))))))))&&((curr.href)==(curr.href))));
        |  pre = curr;
        |  return result;
        |}
        |
        |""".stripMargin
    }


}
