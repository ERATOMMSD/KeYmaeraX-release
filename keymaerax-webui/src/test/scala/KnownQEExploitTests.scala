/**
* Copyright (c) Carnegie Mellon University.
* See LICENSE.txt for the conditions of this license.
*/

import edu.cmu.cs.ls.keymaerax.Configuration
import edu.cmu.cs.ls.keymaerax.btactics.TactixLibrary.QE
import edu.cmu.cs.ls.keymaerax.btactics.TacticTestBase
import edu.cmu.cs.ls.keymaerax.parser.StringConverter._
import edu.cmu.cs.ls.keymaerax.tags.AdvocatusTest

/**
  * Tests with known exploits.
  *
  * @author Stefan Mitsch
  */
@AdvocatusTest
class KnownQEExploitTests extends TacticTestBase {

  "Mathematica" should "not simplify nested max and abs unsoundly" in withMathematica { _ =>
    // proves with Reduce but not with Resolve
    val s = """
      #A>0, B>0, C>0, D>0,
      #abs(m0)>D,
      #dx^2+dy^2=1, (dy*r)^2+(dx*r)^2=r^2,
      #max(abs(m0),abs(n0))>D+A^2/B
      #==>
      #abs(m)>B | abs(n)>E
    """.stripMargin('#').asSequent

    Configuration.set(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS, "true", saveToFile = false)
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Resolve", saveToFile = false)
    proveBy(s, QE) should not be 'proved // correct
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Reduce", saveToFile = false)
    proveBy(s, QE) should /*not*/ be ('proved) // exploit

    Configuration.set(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS, "false", saveToFile = false)
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Resolve", saveToFile = false)
    proveBy(s, QE) should not be 'proved
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Reduce", saveToFile = false)
    proveBy(s, QE) should not be 'proved // fix with expanding all interpreted function symbols
  }

  it should "not simplify nested max and abs unsoundly 2" in withMathematica { _ =>
    // proves with both Reduce and Resolve
    val s = """
      #A>0, B>0, D>0,
      #abs(m0)>D,
      #dx^2+dy^2=1,
      #(dy*r)^2+(dx*r)^2=r^2,
      #max(abs(m0),abs(n0))>D+A^2/B
      #==>
      #abs(m)>D | abs(n)>E
    """.stripMargin('#').asSequent

    Configuration.set(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS, "true", saveToFile = false)
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Resolve", saveToFile = false)
    proveBy(s, QE) should /*not*/ be ('proved)
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Reduce", saveToFile = false)
    proveBy(s, QE) should /*not*/ be ('proved) // exploit

    Configuration.set(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS, "false", saveToFile = false)
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Resolve", saveToFile = false)
    proveBy(s, QE) should not be 'proved // fix with expanding all interpreted function symbols
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Reduce", saveToFile = false)
    proveBy(s, QE) should not be 'proved // fix with expanding all interpreted function symbols
  }

  it should "not simplify nested max and abs unsoundly 3" in withMathematica { _ =>
    // proves with Resolve but not with Reduce
    val s = """
      #B>0, D>0,
      #abs(m0)>D,
      #dx^2+dy^2=1,
      #(dy*r)^2+(dx*r)^2=r^2,
      #max(abs(m0),abs(n0))>D+A^2/B
      #==>
      #abs(m)>D | abs(n)>E
    """.stripMargin('#').asSequent

    Configuration.set(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS, "true", saveToFile = false)
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Resolve", saveToFile = false)
    proveBy(s, QE) should /*not*/ be ('proved) // exploit
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Reduce", saveToFile = false)
    proveBy(s, QE) should not be 'proved // correct

    Configuration.set(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS, "false", saveToFile = false)
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Resolve", saveToFile = false)
    proveBy(s, QE) should not be 'proved // fix with expanding all interpreted function symbols
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Reduce", saveToFile = false)
    proveBy(s, QE) should not be 'proved
  }

  it should "not simplify nested max and abs unsoundly 4" in withMathematica { _ =>
    // proves with Resolve but not with Reduce
    val s = """
      #B>0,
      #abs(m0)>D,
      #dx^2+dy^2=1,
      #(dy*r)^2+(dx*r)^2=r^2,
      #max(abs(m0),abs(n0))>D+A^2/B
      #==>
      #abs(m)>D | abs(n)>E
    """.stripMargin('#').asSequent

    Configuration.set(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS, "true", saveToFile = false)
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Resolve", saveToFile = false)
    proveBy(s, QE) should /*not*/ be ('proved) // exploit
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Reduce", saveToFile = false)
    proveBy(s, QE) should not be 'proved // correct

    Configuration.set(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS, "false", saveToFile = false)
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Resolve", saveToFile = false)
    proveBy(s, QE) should not be 'proved // fix with expanding all interpreted function symbols
    Configuration.set(Configuration.Keys.MATHEMATICA_QE_METHOD, "Reduce", saveToFile = false)
    proveBy(s, QE) should not be 'proved
  }

  it should "insist on terms being reals for unnatural powers" in withMathematica { _ =>
    proveBy("==> (x^(1/2))^2 = x".asSequent, QE) should /*not*/ be ('proved) // exploit
    proveBy("x>=0 ==> (x^(1/2))^2 = x".asSequent, QE) shouldBe 'proved
    proveBy("(x^(1/2))^2 = y ==> y=x".asSequent, QE) should /*not*/ be ('proved) // exploit
    proveBy("x>=0, (x^(1/2))^2 = y ==> y=x".asSequent, QE) shouldBe 'proved
  }

}
