/**
 * Copyright (c) Carnegie Mellon University. CONFIDENTIAL
 * See LICENSE.txt for the conditions of this license.
 */
package edu.cmu.cs.ls.keymaerax.codegen

import edu.cmu.cs.ls.keymaerax.core.{Variable, _}
import edu.cmu.cs.ls.keymaerax.parser.KeYmaeraXPrettyPrinter


/**
 * C++ code generator for ModelPlex monitor expressions.
 * Created by ran on 6/16/15.
 * @author Ran Ji
 * @author Stefan Mitsch
 */
object CGenerator extends CodeGenerator {
  def apply(expr: Expression): String = apply(expr, "long double", Nil, "")
  def apply(expr: Expression, vars: List[Variable]): String = apply(expr, "long double", vars, "")
  def apply(expr: Expression, vars: List[Variable], fileName: String): String = apply(expr, "long double", vars, fileName)
  /** Generate C Code for given expression using the data type cDataType throughout and the input list of variables */
  def apply(expr: Expression, cDataType: String, vars: List[Variable], fileName: String): String = generateCCode(expr, cDataType, vars, fileName)

  /**
   * Generate C code
   *
   * @param expr      KeYmaera X arithmetic expression got from ModelPlex
   * @param cDataType data type
   * @param vars      a list of input variables
   * @param fileName  file name
   * @return          generated C code
   */
  private def generateCCode(expr: Expression, cDataType: String, vars: List[Variable], fileName: String) : String = {
    val names = StaticSemantics.symbols(expr).toList.map(s => nameIdentifier(s))
    require(names.distinct.size == names.size, "Expect unique name_index identifiers for code generation")
    if(names.toSet.intersect(reservedNames).nonEmpty)  println("[warn] Found reserved names: " + names.toSet.intersect(reservedNames).mkString(",") + ". This may cause error.")
    val stateVars = getStateVars(expr, vars)
    if (vars.toSet.diff(stateVars).nonEmpty)
      println("[warn] -vars contains unknown variables {" + vars.toSet.diff(stateVars).map(v => KeYmaeraXPrettyPrinter(v)).mkString(",") + "}, which will be ignored")
    if (stateVars.diff(vars.toSet).nonEmpty)
      println("[info] post variables {" + stateVars.diff(vars.toSet).map(v => KeYmaeraXPrettyPrinter(v)).mkString(",") + "} will be added as parameters")
    val parameters = getParameters(expr, stateVars)
    val funcHead = "/* monitor */\n" + "bool monitor (" + printMonitorArgsDeclaration(stateVars.nonEmpty, parameters.nonEmpty) + ")"
    val funcBody = compile(expr, stateVars, parameters, cDataType)
    infoC(fileName) + includeLib + printParameterDeclaration(parameters, cDataType) + printStateDeclaration(stateVars, cDataType) + funcHead + " {\n" +
      funcBody + "\n}\n\n"
    //@note gcc -Wall -Wextra -Werror -std=c99 -pedantic absolutely wants "newline at end of file" -Wnewline-eof
  }

  /** printings for C */
  private def infoC(fileName: String) =
    s"""/**************************
       | *${if(fileName.nonEmpty) " " + fileName + ".c" else ""}
       | * Generated by KeYmaera X
       | **************************/
       |
       |""".stripMargin
  private val includeLib =
    """#include <math.h>
      |#include <stdbool.h>
      |
      |""".stripMargin

  /** The name of the monitor function argument representing the current state. */
  private val MONITOR_CURR_STATE_NAME = "curr"
  /** The name of the monitor function argument representing monitor parameters. */
  private val MONITOR_PARAMS_NAME = "params"

  /** Prints the monitor argument declarations. */
  private def printMonitorArgsDeclaration(hasState: Boolean, hasParams: Boolean): String =
    ((if (hasState)  Some(s"state $MONITOR_CURR_STATE_NAME")  else None) ::
     (if (hasParams) Some(s"parameters $MONITOR_PARAMS_NAME") else None) :: Nil).flatten.mkString(", ")

  /** Returns the subset of variables in `vars` that represent state in the expression `e`. */
  private def getStateVars(e: Expression, vars: List[Variable]) : Set[NamedSymbol] =
    getPreStateVars(e, vars) ++ getPostStateVars(e, vars)

  /** Returns the subset of `vars` that describe the prior state in expression `e`. */
  private def getPreStateVars(e: Expression, vars: List[Variable]): Set[NamedSymbol] = filterStateVars(e, vars, _ == _)

  /** Returns the subset of `vars` that describe the posterior state in expression `e`. */
  private def getPostStateVars(e: Expression, vars: List[Variable]): Set[NamedSymbol] = filterStateVars(e, vars, _ == _+"post")

  /** Returns the subset of `vars` that satisfy the condition `nameCond` when compared to names in expression `e`. */
  private def filterStateVars(e: Expression, vars: List[Variable], nameCond: (String, String) => Boolean): Set[NamedSymbol] = {
    val allSymbolNames = StaticSemantics.symbols(e)
    vars.flatMap(v => {
      assert(!isInterpretedFunc(v), "[Error] Cannot use " + nameIdentifier(v) + " as variable name, since it is predefined function.")
      if (allSymbolNames.exists(s => nameCond(s.name, v.name) && s.index == v.index)) Some(Variable(v.name, v.index))
      else None
    }).toSet
  }

  /** C Identifier corresponding to a NamedSymbol */
  private def nameIdentifier(s: NamedSymbol): String = {
    require(s.isInstanceOf[Function] || s.isInstanceOf[Variable] || s.isInstanceOf[DifferentialSymbol])
    require(s.sort == Real, "only real-valued symbols are currently supported")
    s match {
      case DifferentialSymbol(x) => nameIdentifier(x) + "__p"
      case _ => if (s.index.isEmpty) s.name else s.name + "_" + s.index.get
    }
  }

  /**
    * Returns a set of names (excluding names in `vars` and interpreted functions) that are immutable parameters of the
    * expression `expr`. */
  private def getParameters(expr: Expression, exclude: Set[NamedSymbol]): Set[NamedSymbol] =
    StaticSemantics.symbols(expr)
      .filter({
        case Function("abs", None, Real, Real, true) => false
        case Function("min" | "max", None, Tuple(Real, Real), Real, true) => false
        case Function(name, _, Unit, _, _) => !exclude.exists(v => v.name == name.stripSuffix("post"))
        case _: Function => false
        case BaseVariable(name, _, _) => !exclude.exists(v => v.name == name.stripSuffix("post"))
      })

  /** Prints the parameters struct declaration. */
  private def printParameterDeclaration(parameters: Set[NamedSymbol], cDataType: String): String =
    printStructDeclaration("parameters", cDataType, parameters)

  /** Prints the state variables struct declaration. */
  private def printStateDeclaration(stateVars: Set[NamedSymbol], cDataType: String): String =
    printStructDeclaration("state", cDataType, stateVars)

  /** Prints a struct declaration named `structName` with a field for each of the names in `vars`. */
  private def printStructDeclaration(structName: String, cDataType: String, vars: Set[NamedSymbol]) = {
    if (vars.nonEmpty) {
      // stable ordering by NamedSymbol.compare
      val parameterDecls = vars.toList.sorted.map({
        case x: Variable => convertSorts(x.sort, cDataType) + " " + nameIdentifier(x)
        case f: Function =>
          assert(!isInterpretedFunc(f), "Parameter must not be an interpreted function")
          assert(f.domain == Unit, "If declared as function, parameter must have domain Unit, but has " + f.domain)
          convertSorts(f.sort, cDataType) + " " + nameIdentifier(f)
        case _ => None
      }).mkString(";\n  ")
      s"""typedef struct $structName {
         |  $parameterDecls;
         |} $structName;
         |
        |""".stripMargin
    } else ""
  }

  /** convert to C Type for the given KeYmaera X Sort */
  private def convertSorts(t: Sort, cDataType: String) : String = t match {
    case Unit => ""
    case Real => cDataType
    case Bool => "bool"
    case Tuple(l, r) => convertSorts(l, cDataType) + ", " + convertSorts(r, cDataType)
    case _ => t.toString
  }

  /** Some reserved names, such as: main, Main */
  private def reservedNames = Set("main", "Main")

  /** Indicates whether the name `f` is an interpreted function symbol. */
  private def isInterpretedFunc(f: NamedSymbol) : Boolean = f match {
    case Function(_, _, _, _, interpreted) => interpreted
    case _ => false
  }

  /** Convert predefined functions to corresponding C functions
    *
    * C 99 standard:
    *   double fabs()
    *   float fabsf()
    *   long double fabsl()
    */
  private def convertPredefFuncs(funcName: String, cDataType: String) : String = {
    assert(funcName=="abs" || funcName=="min" || funcName=="max")

    val suffix =
      if(cDataType == "float") "f"
      else if(cDataType == "long double") "l"
      else ""

    if(funcName == "abs") "fabs" + suffix
    else if(funcName == "min") "fmin" + suffix
    else if(funcName == "max") "fmax" + suffix
    else ""
  }

  /**
    * Compiles the expression `e` to C code as a body of a monitor function.
    * Names in `stateVars` are fields of the monitor function's argument "curr", names in `parameters` are fields of
    * the argument "params".
    *
    * @param e           given expression
    * @param parameters the list of names need to be declared as function calls,
    *                    which helps to determine whether a variable encountered in expression should be generated as a nullary function
    * @return            generated C code
    */
  private def compile(e: Expression, stateVars: Set[NamedSymbol], parameters: Set[NamedSymbol], cDataType: String) = {
    val compiledExpr = e match {
      case f : Formula => compileFormula(f, parameters, cDataType)
      case _ => throw new CodeGenerationException("The input expression: \n" + KeYmaeraXPrettyPrinter(e) + "\nis expected to be formula.")
    }

    if (stateVars.nonEmpty) {
      s"""  static state pre;
         |  static bool isInitialized = false;
         |  bool result = false;
         |  if (!isInitialized) {
         |    isInitialized = true;
         |    result = true;
         |  } else {
         |    result = $compiledExpr;
         |  }
         |  pre = curr;
         |  return result;""".stripMargin
    } else {
      s"  return $compiledExpr;"
    }
  }

  /** Compile a term to a C expression evaluating it (in the same arithmetic) */
  private def compileTerm(t: Term, parameters: Set[NamedSymbol], cDataType: String) : String = {
    require(t.sort == Real || t.sort == Unit || t.sort.isInstanceOf[Tuple], "can only deal with reals not with sort " + t.sort)
    t match {
      case Neg(c)       => "-" + "(" + compileTerm(c, parameters, cDataType) + ")"
      case Plus(l, r)   => "(" + compileTerm(l, parameters, cDataType) + ")" + " + " + "(" + compileTerm(r, parameters, cDataType) + ")"
      case Minus(l, r)  => "(" + compileTerm(l, parameters, cDataType) + ")" + " - " + "(" + compileTerm(r, parameters, cDataType) + ")"
      case Times(l, r)  => "(" + compileTerm(l, parameters, cDataType) + ")" +  "*"  + "(" + compileTerm(r, parameters, cDataType) + ")"
      case Divide(l, r) => "(" + compileTerm(l, parameters, cDataType) + ")" +  "/"  + "(" + compileTerm(r, parameters, cDataType) + ")"
      case Power(l, r)  => "(" + compilePower(l, r, parameters, cDataType) + ")"
      // atomic terms
      case Number(n) =>
        assert(n.isDecimalDouble || n.isValidLong, throw new CodeGenerationException("Term " + KeYmaeraXPrettyPrinter(t) + " contains illegal-precision numbers"))
        //@note assume the C compiler will detect representation-size errors
        //if(n.toDouble < 0)  "(" + n.underlying().toString + ")"
        //else n.underlying().toString
        //@note with parentheses in case literal is negative
        "(" + n.underlying().toString + ")"
      case t: Variable if  parameters.contains(t) => "params." + nameIdentifier(t)
      case t: Variable if !parameters.contains(t) => "pre." + nameIdentifier(t)
      case FuncOf(fn, Nothing) if  parameters.contains(fn) => "params." + nameIdentifier(fn)
      //@note _idx are aliases for the same post variable
      case FuncOf(fn@Function(fname, _, fdom, fsort, fintr), Nothing) if !parameters.contains(fn) &&  fname.endsWith("post") =>
        "curr." + nameIdentifier(Function(fname.stripSuffix("post"), None, fdom, fsort, fintr))
      case FuncOf(fn, Nothing) if !parameters.contains(fn) && !fn.name.endsWith("post") => ???
      case FuncOf(fn, child) if fn.interpreted =>
        nameIdentifier(fn) match {
          case "abs" => convertPredefFuncs("abs", cDataType) + "(" + compileTerm(child, parameters, cDataType) + ")"
          case "min" => convertPredefFuncs("min", cDataType) + "(" + compileTerm(child, parameters, cDataType) + ")"
          case "max" => convertPredefFuncs("max", cDataType) + "(" + compileTerm(child, parameters, cDataType) + ")"
          case _ => nameIdentifier(fn) + "(" + compileTerm(child, parameters, cDataType) + ")"
        }
      case FuncOf(fn, _) if !fn.interpreted => ???
      case Pair(l, r)  => compileTerm(l, parameters, cDataType) + ", " + compileTerm(r, parameters, cDataType)
      // otherwise exception
      case _ => throw new CodeGenerationException("Conversion of term " + KeYmaeraXPrettyPrinter(t) + " is not defined")
    }
  }

  /**
   * Compile exponentials
   * @param base  base of the exponential
   * @param exp   index of the exponential
   * @return      simplified generation of exponential
   */
  private def compilePower(base: Term, exp: Term, calledFuncs: Set[NamedSymbol], cDataType: String) : String = {
    if(base.equals(Number(0))) {
      //@todo since when is that the case?
      println("[warning] generating 0^0")
      if(exp.equals(Number(0))) "1.0" // 0^0 =1
      else "0.0"  // 0^x = 0
    } else {
      exp match {
        case Number(n) =>
          if(n.isValidInt) {
            // index is integer
            if(n.intValue() == 0) {
              // index is 0, x^0 = 1
              //            assert(!base.equals(Number(0)), throw new CodeGenerationException("Conversion of 0^0 is not defined"))
              "1.0"
            } else if (n.intValue() > 0 ) {
              // index n is a positive integer, expand n times of *
              val ba : String = compileTerm(base, calledFuncs, cDataType)
              (0 until n.intValue()).map(_ => s"($ba)").mkString("*")
            } else "1.0/" + "(" + compilePower(base, Number(n.underlying().negate()), calledFuncs, cDataType) + ")" // index is negative integer
          } else "pow(" + "(" + compileTerm(base, calledFuncs, cDataType) + ")" + "," + "(" + compileTerm(exp, calledFuncs, cDataType) + ")" + ")" // index is not integer, use pow function in C
        case Neg(Number(n)) => "1.0/" + "(" + compilePower(base, Number(n), calledFuncs, cDataType) + ")"  // index is negative
        case _ => "pow(" + "(" + compileTerm(base, calledFuncs, cDataType) + ")" + "," + "(" + compileTerm(exp, calledFuncs, cDataType) + ")" + ")"
      }
    }
  }


  /** Compile a formula to a C expression checking it (in the same arithmetic) */
  private def compileFormula(f: Formula, parameters: Set[NamedSymbol], cDataType: String) : String = {
    f match {
      case Not(ff)     => "!" + "(" + compileFormula(ff, parameters, cDataType) + ")"
      case And(l, r)   => "(" + compileFormula(l, parameters, cDataType) + ")" + "&&" + "(" + compileFormula(r, parameters, cDataType) + ")"
      case Or(l, r)    => "(" + compileFormula(l, parameters, cDataType) + ")" + "||" + "(" + compileFormula(r, parameters, cDataType) + ")"
      //@todo the following two transformations of formulas should be done by a tactic and just asserted here that these cases no longer happen.
      case Imply(l, r) => compileFormula(Or(Not(l), r), parameters, cDataType)
      case Equiv(l, r) => compileFormula(And(Imply(l, r), Imply(r, l)), parameters, cDataType)
      //compileFormula(Or(And(l,r),And(Not(l),Not(r))))
      case Equal(l, r)       => "(" + compileTerm(l, parameters, cDataType) + ")" + "==" + "(" + compileTerm(r, parameters, cDataType) + ")"
      case NotEqual(l, r)    => "(" + compileTerm(l, parameters, cDataType) + ")" + "!=" + "(" + compileTerm(r, parameters, cDataType) + ")"
      case Greater(l,r)      => "(" + compileTerm(l, parameters, cDataType) + ")" + ">"  + "(" + compileTerm(r, parameters, cDataType) + ")"
      case GreaterEqual(l,r) => "(" + compileTerm(l, parameters, cDataType) + ")" + ">=" + "(" + compileTerm(r, parameters, cDataType) + ")"
      case Less(l,r)         => "(" + compileTerm(l, parameters, cDataType) + ")" + "<"  + "(" + compileTerm(r, parameters, cDataType) + ")"
      case LessEqual(l,r)    => "(" + compileTerm(l, parameters, cDataType) + ")" + "<=" + "(" + compileTerm(r, parameters, cDataType) + ")"
      case True              => "true"
      case False             => "false"
      case Box(_, _) | Diamond(_, _) => throw new CodeGenerationException("Conversion of Box or Diamond modality is not allowed")
      case _ => throw new CodeGenerationException("Conversion of formula " + KeYmaeraXPrettyPrinter(f) + " is not defined")
    }
  }
}