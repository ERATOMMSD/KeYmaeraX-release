Theorem "Theorem 1: Static safety".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b())).              /* The straight-line stopping distance from brake start to full stop. */
  R accelComp(R) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*(.)))./* Straight-line distance to compensate acceleration */
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).     /* Separation that allows accelerating on a new curve */

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](x - xo)^2 + (y - yo)^2 > 0
End.

Tactic "Proof Theorem 1: Static safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo)>v_0^2/(2*b())+(A()/b()+1)*(A()/2*t^2+t*v_0)`}, 'L=={`abs(x_0-xo)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo)>v_0^2/(2*b())+(A()/b()+1)*(A()/2*t^2+t*v_0)`}, 'L=={`abs(y_0-yo)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`abs(x-xo_0)>stopDist(v)|abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 2: Passive safety".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b()) + V()*(.)/b()).
  R accelComp(R) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*((.)+V))).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 2: Passive safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 3: Passive Friendly Safety".
Functions.
  R ep().      /* time limit for control decisions */
  R tau().     /* time limit for obstacle reaction */
  R b().       /* minimum braking capability of the robot */
  R bo().      /* obstacle brakes */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R friendlyMargin(R) = ( (.)^2/(2*bo()) + tau()*(.) ).
  R stopDist(R) = ((.)^2 / (2*b()) + V()*(.)/b()).
  R accelComp(R) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*((.)+V))).
  R admissibleSeparation(R) = (stopDist(.) + friendlyMargin(V()) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & tau() >= 0
    & bo() > 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (abs(x-xo) > friendlyMargin(V()) | abs(y-yo) > friendlyMargin(V()))
    & vxo^2+vyo^2<=V()^2
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v)+friendlyMargin(V()) | abs(y-yo) > stopDist(v)+friendlyMargin(V()))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R vo.   /* refined obstacle: speed, acceleration, and direction */
  R ao.
  R dxo.
  R dyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V()^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep() & v >= 0
      }
    }*@invariant(loopinv())
  ](  (v>0 -> (x - xo)^2 + (y - yo)^2 > (friendlyMargin(V()))^2)                     /* robot ensures friendly margin */
    & (  0<=vo & vo^2=vxo^2+vyo^2 & dxo*vo=vxo & dyo*vo=vyo                                      /* obstacle can stop */
       & (x - xo)^2 + (y - yo)^2 > (friendlyMargin(V()))^2
       ->
        <{
          ao := *; ?-bo() <= ao & vo + ao*ep() <= V();
          t := 0;
          {xo'=vo*dxo, yo'=vo*dyo, vo'=ao, t'=1 & vo>=0 & t<=ep()}
         }*>((x-xo)^2 + (y-yo)^2 > 0 & vo=0))
  )
End.

Tactic "Proof Theorem 3: Passive Friendly Safety".
  tactic obstacleCanStop as (
    unfold ; cut({`vo=0|dxo^2+dyo^2=1`}) ; <(
      cut({`vo<=V()`}) ; <(
        hideL('L=={`vo^2=vxo^2+vyo^2`}) ; hideL('L=={`vxo^2+vyo^2<=V()^2`});
        con({`(vo=0|dxo^2+dyo^2=1)&bo()>0&ep()>0&(x-xo)^2+(y-yo)^2>(vo^2/(2*bo()))^2&0<=vo&vo<=V()&(v*ep()*bo()>=vo|vo=0)`}, 1); <(
          QE,
          unfold ; existsR({`-bo()`}, 1) ; unfold ; <(
            fullSimplify ; closeTrue
            ,
            solve(1) ; existsR({`min((vo/bo(),ep()))`}, 1) ; abbrv({`min((vo/bo(),ep()))`}, {`minT`}) ; minmax(-10.1) ;
            orL('L=={`vo=0|dxo^2+dyo^2=1`}) ; doall(QE)
            ,
            QE
          )
          ,
          QE
        )
        ,
        hideR(1) ; QE
      ),
      hideR(1) ; QE
    )
  );

  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+fm+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+fm+(A()/b()+1)*(A()/2*ep()^2+ep()*(v_0+V()))`});
    hideR('R=={`abs(y-yo)>stopDist(v)+fm`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+fm+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+fm+(A()/b()+1)*(A()/2*ep()^2+ep()*(v_0+V()))`});
    hideR('R=={`abs(x-xo)>stopDist(v)+fm`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic robotAlwaysStops as (
    loop({`loopinv()`}, 1); <(
      print({`Base case...`}); smartQE; print({`Base case done`})
      ,
      print({`Use case...`}); smartQE; print({`Use case done`})
      ,
      print({`Induction step`}); unfold; <(
        print({`Braking branch`});
        abbrv({`(V()^2/(2*bo())+tau()*V())`}, {`fm`});
        cut({`fm>=0`}); <(hideL('L=={`fm=(V()^2/(2*bo())+tau()*V())`}), hideR(1); QE);
        dib; dw; prop; doall(smartQE); print({`Braking branch done`})
        ,
        print({`Stopped branch`});
        abbrv({`(V()^2/(2*bo())+tau()*V())`}, {`fm`});
        cut({`fm>=0`}); <(hideL('L=={`fm=(V()^2/(2*bo())+tau()*V())`}), hideR(1); QE);
        di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
        ,
        print({`Acceleration branch`});
        hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v)+friendlyMargin(V()) | abs(y-yo_0)>stopDist(v)+friendlyMargin(V())`});
        abbrv({`(V()^2/(2*bo())+tau()*V())`}, {`fm`});
        cut({`fm>=0`}); <(hideL('L=={`fm=(V()^2/(2*bo())+tau()*V())`}), hideR(1); QE);
        dia; dw;
        prop; <(
          xAccArith,
          yAccArith
        );
        print({`Acceleration branch done`})
      );
      print({`Induction step done`})
    );
    done;
    print({`Robot done`})
  );

  implyR(1) ; andL('L)* ; boxAnd(1) ; andR(1) ; <(
    robotAlwaysStops
    ,
    MR({`vxo^2+vyo^2<=V()^2`},1); <(
      loop({`vxo^2+vyo^2<=V()^2`}, 1) ; <(
        closeId,
        closeId,
        composeb(1) ; GV(1.1) ; composeb(1) ; GV(1.1) ; master
      )
      ,
      andL('L)* ;
      hideL('L=={`A()>=0`});
      hideL('L=={`b()>0`});
      obstacleCanStop
    )

  )
End.

End.

Theorem "Theorem 4: Passive orientation safety".
Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Gamma().   /* Sensor range in radian */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R)   = ( (.)^2 / (2*b()) ).
  R stopMargin(R) = ( stopDist(.) + V()*(.)/b() ).
  R accelComp(R)  = ( (A()/b() + 1) * (A()/2 * ep()^2 + ep()*(.)) ).
  R accelMargin(R)  = ( accelComp(.) + (A()/b() + 1)*ep()*V() ).
  R admissibleSeparation(R) = ( stopMargin(.) + accelMargin(.) ).
  R admissibleTurnLength(R) = ( stopDist(.) + accelComp(.) ).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B isVisible(R) <-> ((.)>0).      /* Indicates whether or not the obstacle is visible for the robot at the decision. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Gamma() > 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & beta = 0
    & r != 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & r != 0
    & (v>0 -> ( (abs(x-xo) > stopMargin(v) | abs(y-yo) > stopMargin(v))
              | (!isVisible(visDeg) & abs(beta) + stopDist(v)/abs(r) < Gamma() )) )
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
  R beta. /* Angle that the robot traveled since it last chose a new curve */
  R visDeg. /* Indicates the "degree" to which the obstacle is visible to the robot (input to isVisible) */
End.

Problem.
  assumptions() -> [
      {
        {
        /* obstacle control */
        {
          vxo := *;
          vyo := *;
          ?vxo^2+vyo^2 <= V()^2;
        }

        /* robot control */
        {
           /* brake on current curve. If the velocity is zero this just means that the robot remains stopped */
           {a := -b();}
        ++ /* When we are stopped, both translational and rotational acceleration are 0 */
           {?v=0; a := 0; w := 0;}
        ++ /* or choose a new safe curve */
           {a := A();
            beta := 0;
            r :=*; ?r!=0;

            /* measure obstacle position and whether or not it is visible to the robot */
            xo := *; yo := *; visDeg := *;
            ?(isVisible(visDeg) ->
               ( abs(x-xo) > admissibleSeparation(v)
               | abs(y-yo) > admissibleSeparation(v)) );
            ?admissibleTurnLength(v) < Gamma()*abs(r);
            }
        }

        /* Reset the clocks */
        t := 0;
        /* Set w according to physics (rigid body motion) */
        w :=*; ?w*r = v;
        }

        {x' = v * dx, y' = v * dy, dx' = -w * dy, dy' = w * dx, v' = a, w' = a/r, beta'=w,
                      xo' = vxo, yo' = vyo, t' = 1 & (t <= ep & v >= 0)}
      }*
    ] (v > 0 -> ((x - xo)^2 + (y - yo)^2 > 0 | (!isVisible(visDeg) & (abs(beta) < Gamma()))) )
End.

Tactic "Proof Theorem 4: Passive orientation safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1);
    diffInvariant({`w*r=v`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`beta = old(beta) + t/r*(v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`beta = old(beta)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`beta = old(beta) + t/r*(v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    hideR('R=={`abs(y-yo)>stopMargin(v)`});
    hideL('L=={`-t*(v-A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v-A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+((A()/b()+1)*(A()/2*t^2+t*v_0)+(A()/b()+1)*t*V())`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    hideR('R=={`abs(x-xo)>stopMargin(v)`});
    hideL('L=={`-t*(v-A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v-A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+((A()/b()+1)*(A()/2*t^2+t*v_0)+(A()/b()+1)*t*V())`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop ; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0->((abs(x-xo_0)>stopMargin(v)|abs(y-yo_0)>stopMargin(v))|!isVisible(visDeg_0)&abs(beta_0)+stopDist(v)/abs(r_0) < Gamma())`});
      unfold;
      dia; dw;
      print({`Acceleration arithmetic`});
      implyR(1) ; andL('L)* ; fullSimplify ; implyR(1) ; orR(1) ; notGreater(2.0) ; orR(1) ;
      implyL('L=={`isVisible(visDeg) -> ( abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0))`}) ; <(
        hideR('R=={`abs(x-xo)>stopMargin(v)`}) ; hideR('R=={`abs(y-yo)>stopMargin(v)`}) ; andR(1) ; doall(smartQE)
        ,
        print({`Acc Distance`});
        hideL('L=={`admissibleTurnLength(v_0) < Gamma()*abs(r)`}) ;
        hideR('R=={`visDeg<=0 & abs(beta) + stopDist(v)/abs(r) < Gamma()`});
        hideL('L=={`r_0!=0`});
        hideL('L=={`vxo^2+vyo^2<=V()^2`});
        hideL('L=={`dx^2+dy^2=1`});
        hideL('L=={`Gamma()>0`});
        hideL('L=={`beta_0=0`});
        hideL('L=={`w*r=v`});
        hideL('L=={`beta=beta_0+t/r*(v-A()/2*t)`});
        orL('L=={`abs(x_0-xo_0)>admissibleSeparation(v_0) | abs(y_0-yo_0)>admissibleSeparation(v_0)`}); <(
          xAccArith
          ,
          yAccArith
        )
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 5: Passive safety with actual acceleration".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b()) + V()*(.)/b()).
  /*R accelComp(R) = ((a/b() + 1) * (a/2 * ep()^2 + ep()*((.)+V))).
  R admissibleSeparationG(R) = (stopDist(.) + accelComp(.)).
  R admissibleSeparationL(R) = (-(.)^2/(2*a)-V*(.)/a).*/

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := *; ?-b<=a & a<=A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            if (v+a*ep>=0) { ?abs(x-xo) > stopDist(v) + (a/b+1)*(a/2*ep^2 + ep*(v+V)) | abs(y-yo) > stopDist(v) + (a/b+1)*(a/2*ep^2 + ep*(v+V)); }
            else           { ?abs(x-xo) > -v^2/(2*a)-V*v/a | abs(y-yo) > -v^2/(2*a)-V*v/a; }
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 5: Passive safety with actual acceleration".
  tactic diall as (
    diffInvariant({`t>=0`}, 'R);
    diffInvariant({`isWellformedDir()`}, 'R);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 'R);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 'R)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 'R);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 'R);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 'R)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 'R);
    diffInvariant({`x = old(x)`}, 'R);
    diffInvariant({`y = old(y)`}, 'R)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + a*t`}, 'R);
    diffInvariant({`-t * (v - a/2*t) <= x - old(x) & x - old(x) <= t * (v - a/2*t)`}, 'R);
    diffInvariant({`-t * (v - a/2*t) <= y - old(y) & y - old(y) <= t * (v - a/2*t)`}, 'R)
  );

  tactic dw as (andL('L)*; dW('R));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    ?(transform({`abs(x_0-xo_0)>stopDist(v_0) + (a/b+1)*(a/2*t^2 + t*(v_0+V))`}, 'L=={`abs(x_0-xo_0)>stopDist(v_0) + (a/b+1)*(a/2*ep^2 + ep*(v_0+V))`}));
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    ?(transform({`abs(y_0-yo_0)>stopDist(v_0) + (a/b+1)*(a/2*t^2 + t*(v_0+V))`}, 'L=={`abs(y_0-yo_0)>stopDist(v_0) + (a/b+1)*(a/2*ep^2 + ep*(v_0+V))`}));
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Free driving non-stopping branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Free driving non-stopping branch done`})
      ,
      print({`Free driving stopping branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Free driving stopping branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 6: Passive safety despite location uncertainty".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Dp().      /* maximum location uncertainty */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b()) + V()*(.)/b()).
  R accelComp(R) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*((.)+V())) + Dp()).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Dp() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R mx.   /* robot measured position: x */
  R my.   /* robot measured position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* locate */
        {
          mx := *; my := *;
          ?(mx-x)^2+(my-y)^2 <= Dp()^2;
        }
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(mx-xo) > admissibleSeparation(v)
            | abs(my-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 6: Passive safety despite location uncertainty".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(mx-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))+Dp()`}, 'L=={`abs(mx-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(my-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))+Dp()`}, 'L=={`abs(my-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 7: Passive safety despite actuator perturbation".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Da().      /* maximum actuator perturbation 0< Da <= 1 (robot will not loose brakes entirely) */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ( (.)^2 / (2*(b()*Da())) + V()*(.)/(b()*Da()) ).
  R accelComp(R) = ( (A()/(b()*Da()) + 1) * (A()/2 * ep()^2 + ep()*((.)+V())) ).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & 0 < Da() & Da() <= 1
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot control choice: translational acceleration */
  R da.   /* robot actuator disturbance */
  R acc.  /* robot actual translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
        /* actuator perturbation */
        {
          da := *; ?(Da<=da & da<=1); acc := da*a;
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = acc,      /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = acc/r, /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 7: Passive safety despite actuator perturbation".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v <= old(v) - (b()*Da())*t`}, 1);
    diffInvariant({`-t * (old(v) - (b()*Da())/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - (b()*Da())/2*t)`}, 1);
    diffInvariant({`-t * (old(v) - (b()*Da())/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - (b()*Da())/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v <= old(v) + A()*t`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*(b()*Da()))+V()*v_0/(b()*Da())+(A()/(b()*Da())+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE);
    hideL('L=={`t<=ep()`});
    hideL('L=={`b()>0`});
    hideL('L=={`ep()>0`});
    hideL('L=={`0<Da()`});
    hideL('L=={`Da()<=1`});
    hideL('L=={`Da()<=da`});
    hideL('L=={`da<=1`});
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*(b()*Da()))+V()*v_0/(b()*Da())+(A()/(b()*Da())+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE);
    hideL('L=={`t<=ep()`});
    hideL('L=={`b()>0`});
    hideL('L=={`ep()>0`});
    hideL('L=={`0<Da()`});
    hideL('L=={`Da()<=1`});
    hideL('L=={`Da()<=da`});
    hideL('L=={`da<=1`});
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE); prop; doall(print({`Braking QE`}); smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 8: Passive safety despite velocity uncertainty".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Dv().      /* maximum velocity uncertainty */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ( (.)^2 / (2*b()) + V()*(.)/b() ).
  R accelComp(R) = ( (A()/b() + 1) * (A()/2 * ep()^2 + ep()*((.)+V())) ).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Dv() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R mv.   /* robot measured velocity */
  R a.    /* robot control choice: translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* sense */
        {
          mv := *; ?0<=mv & v-Dv()<=mv & mv<=v+Dv();
        }
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(mv+Dv())
            | abs(y-yo) > admissibleSeparation(mv+Dv());
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 8: Passive safety despite velocity uncertainty".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v <= old(v) - b()*t`}, 1);
    diffInvariant({`-t * (old(v) - b()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) - b()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v <= old(v) + A()*t`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(mv+Dv())`});
    hideL('L=={`t<=ep()`});
    hideL('L=={`ep()>0`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(mv+Dv())`});
    hideL('L=={`t<=ep()`});
    hideL('L=={`ep()>0`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(print({`Braking QE`}); smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 9: Passive safety for asynchronous controllers".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b()) + V()*(.)/b()).
  R accelComp(R) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*((.)+V))).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 + (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).

  /* todo invariant lookup for inner fails */
  B innerloopinv() <-> (
    0<=t & t<=ep()
    & v >= 0
    & isWellformedDir()
    & -t*V() <= xo - old(xo) & xo - old(xo) <= t*V() /* todo: old(.) support in loop invariants */
    & -t*V() <= yo - old(yo) & yo - old(yo) <= t*V()
    & -t * (v - a/2*t) <= x - old(x) & x - old(x) <= t * (v - a/2*t)
    & -t * (v - a/2*t) <= y - old(y) & y - old(y) <= t * (v - a/2*t)
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        };
        /* dynamics */
        { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
          dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
          xo' = vxo, yo' = vyo,                    /* obstacle moves */
          t' = 1 & t <= ep & v >= 0
        }
      }*@invariant(innerloopinv())
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 9: Passive safety for asynchronous controllers".
  tactic diall as (
    diffInvariant({`t>=old(t)`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-(t-old(t))*V() <= xo - old(xo) & xo - old(xo) <= (t-old(t))*V()`}, 1);
    diffInvariant({`-(t-old(t))*V() <= yo - old(yo) & yo - old(yo) <= (t-old(t))*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*(t-old(t))`}, 1);
    diffInvariant({`-(t-old(t)) * (v + b()/2*(t-old(t))) <= x - old(x) & x - old(x) <= (t-old(t)) * (v + b()/2*(t-old(t)))`}, 1);
    diffInvariant({`-(t-old(t)) * (v + b()/2*(t-old(t))) <= y - old(y) & y - old(y) <= (t-old(t)) * (v + b()/2*(t-old(t)))`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*(t-old(t))`}, 1);
    diffInvariant({`-(t-old(t)) * (v - A()/2*(t-old(t))) <= x - old(x) & x - old(x) <= (t-old(t)) * (v - A()/2*(t-old(t)))`}, 1);
    diffInvariant({`-(t-old(t)) * (v - A()/2*(t-old(t))) <= y - old(y) & y - old(y) <= (t-old(t)) * (v - A()/2*(t-old(t)))`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic ghosts as (
    discreteGhost({`v`}, 1) ; discreteGhost({`x`}, 1) ; discreteGhost({`y`}, 1) ; discreteGhost({`xo`}, 1) ;
    discreteGhost({`yo`}, 1) ; (assignEquality(1) ; allR2L('Llast))*5
  );

  tactic innerUseCase as (
    andR(1) ; <(
    prop,
    andR(1) ; <(
      prop,
      implyR(1) ; orR(1) ; implyL('L=={`v_0>0 -> abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)`}) ; <(
        QE,
        orL('L=={`abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)`}) ; <(
          hideR('R=={`abs(y-yo) > stopDist(v)`}); smartQE,
          hideR('R=={`abs(x-xo) > stopDist(v)`}); smartQE
          )
        )
      )
    )
  );

  tactic brakingInnerLoop as (
    ghosts;
    loop({`0<=t&t<=ep()&v>=0&dx^2+dy^2=1&v=v_0-b()*t&-t*V()<=xo-xo_0&xo-xo_0<=t*V()&-t*V()<=yo-yo_0&yo-yo_0<=t*V()&-t*(v+b()/2*t)<=x-x_0&x-x_0<=t*(v+b()/2*t)&-t*(v+b()/2*t)<=y-y_0&y-y_0<=t*(v+b()/2*t)`}, 1) ; <(
      QE,
      innerUseCase,
      unfold;
      hideL('L=={`v_0>0 -> abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)`});
      dib; dw; unfold; doall(smartQE)
    )
  );

  tactic stoppedInnerLoop as (
    ghosts;
    loop({`0<=t&t<=ep()&v>=0&dx^2+dy^2=1&v=v_0&-t*V()<=xo-xo_0&xo-xo_0<=t*V()&-t*V()<=yo-yo_0&yo-yo_0<=t*V()&x=x_0&y=y_0`}, 1) ; <(
      QE,
      innerUseCase,
      unfold;
      hideL('L=={`v_0>0 -> abs(x_0-xo_0) > stopDist(v_0) | abs(y_0-yo_0) > stopDist(v_0)`});
      di0; dw; unfold; doall(smartQE)
    )
  );

  tactic accInnerLoop as (
    hideL('L=={`v>0 -> abs(x-xo_0) > stopDist(v) | abs(y-yo_0) > stopDist(v)`}) ;
    ghosts;
    loop({`0<=t&t<=ep()&v>=0&dx^2+dy^2=1&v=v_0+A()*t&-t*V()<=xo-xo_0&xo-xo_0<=t*V()&-t*V()<=yo-yo_0&yo-yo_0<=t*V()&-t*(v-A()/2*t)<=x-x_0&x-x_0<=t*(v-A()/2*t)&-t*(v-A()/2*t)<=y-y_0&y-y_0<=t*(v-A()/2*t)`}, 1) ; <(
      QE,
      andR(1) ; <(
        prop,
        andR(1) ; <(
          prop,
          implyR(1) ; orR(1) ;
          orL('L=={`abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0)`}); <(
            transform({`abs(x_0-xo_0) > v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
            hideR('R=={`abs(y-yo) > stopDist(v)`}); smartQE
            ,
            transform({`abs(y_0-yo_0) > v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
            hideR('R=={`abs(x-xo) > stopDist(v)`}); smartQE
          )
        )
      ),
      unfold; hideL('L=={`abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0)`});
      dia; dw; unfold; doall(smartQE)
    )
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); brakingInnerLoop; print({`Braking branch done`})
      ,
      print({`Stopped branch`}); stoppedInnerLoop; print({`Stopped branch done`})
      ,
      print({`Acceleration branch`}); accInnerLoop; print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

Theorem "Theorem 11: Reach waypoint".

/*
 *	Robot must stop within distance delta at goal.
 *
 *  Robot
 * 	- must stop within distance delta of goal
 *  - can only drive straight and forward
 *  - ensures progress towards goal
 *
 *  Liveness property:
 *  - Robot can stop at goal
 *
 */

Functions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R GDelta().	 /* goal area size */
	R Vmax().    /* robot cannot go faster than this */

	R waypointStartDist(R) = ( (.)-GDelta() ).
	R waypointEndDist(R)   = ( (.)+GDelta() ).

  R minV() = ( A()*ep() ).

	R stopDist(R) = ( (.)^2/(2*b()) ).
	R accComp(R)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*(.)) ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmax() >= 2*A()*ep()
    & GDelta() > Vmax()*ep() + Vmax()^2/(2*b())                            /* waypoint is large enough that robot can
                                                                                  start driving and still stop inside */
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    vr = 0
    & xr < waypointStartDist(xg)
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B loopinv() <-> (
	  0 <= vr & vr <= Vmax & xr + stopDist(vr) < waypointEndDist(xg)
	).
End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xg.		/* goal position */
	R t.		/* control cycle time */
End.

Problem.
  assumptions()
	  ->
	  /* safety */
	  [
      {	{
        {
              ar := -b();
           ++ ?vr = 0; ar := 0;
           ++ ?xr + stopDist(vr) + accComp(vr) < waypointEndDist(xg) & vr+A()*ep()<=Vmax(); ar := A();
           ++ ?xr <= waypointStartDist(xg) & vr <= Vmax(); ar := *; ?-b() <= ar & ar <= (Vmax()-vr)/ep() & ar <= A();
        }
        /* dynamics */
        t := 0;
        }
        {xr' = vr, vr' = ar, t' = 1 & t <= ep() & vr >= 0}
      }*@invariant(loopinv())
		] (xr < waypointEndDist(xg))
		&
		/* liveness */
		<
      {	{
        {
              ar := -b();
           ++ ?vr = 0; ar := 0;
           ++ ?xr + stopDist(vr) + accComp(vr) < waypointEndDist(xg) & vr+A()*ep()<=Vmax(); ar := A();
           ++ ?xr <= waypointStartDist(xg) & vr <= Vmax(); ar := *; ?-b() <= ar & ar <= (Vmax()-vr)/ep() & ar <= A();
        }
        /* dynamics */
        t := 0;
        }
        {xr' = vr, vr' = ar, t' = 1 & t <= ep() & vr >= 0}
      }*
		>(waypointStartDist(xg) < xr)
End.

Tactic "Proof Theorem 11: Reach waypoint".
  implyR(1) ; andL('L)* ; andR(1) ; <(
    master,
    iterated(1) ; orR(1) ; composed(2) ; composed(2) ; choiced(2) ; orR(2) ; hideR(2) ; choiced(2) ; orR(2) ;
    hideR(2) ; choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; andR(2) ; <(
      QE,
      composed(2) ; randomd(2) ; existsR({`min(((Vmax()-vr)/ep(),A()))`}, 2) ; testd(2) ; andR(2) ; <(
        QE,
        assignd(2) ; allR(2) ; implyR(2) ; solve(2) ; existsR({`ep()`}, 2) ; andR(2) ; <(
          QE,
          andR(2) ; <(
            QE,
            existsR({`ar*ep()+vr_1`}, 2) ; simplify(2) ;
            existsR({`ar/2*ep()^2+vr_1*ep()+xr_1`}, 2) ; simplify(2) ;
            con({`Vmax()>0&A()>0&b()>0&ep()>0&0 < vr&vr<=Vmax()&xg-GDelta() < xr+v*ep()*vr`}, 2) ; <(
              QE,
              composed(1) ; composed(1) ; cut({`xr<=xg-GDelta()|xg-GDelta() < xr`}) ; <(
                orL('L=={`xr<=xg-GDelta()|xg-GDelta() < xr`}) ; <(
                  choiced(1) ; orR(1) ; hideR(1) ; choiced(1) ; orR(1) ; hideR(1) ; choiced(1) ; orR(1) ;
                  hideR(1) ; composed(1) ; testd(1) ; andR(1) ; <(
                    master,
                    composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
                      QE,
                      assignd(1) ; allR(1) ; implyR(1) ; solve(1) ; QE
                      )
                    ),
                  choiced(1) ; orR(1) ; hideR(2) ; assignd(1) ; assignd(1) ; allR(1) ; implyR(1) ; solve(1) ; QE
                  ),
                hideR(1) ; QE
                ),
              QE
              )
            )
          )
        )
      )
    )
End.

End.

Theorem "Theorem 12: Cross intersection".

/*
 *	Robot must safely cross an intersection.
 *
 *  Robot
 * 	- must cross intersection safely
 *  - can only drive straight and forward
 *  - ensures progress towards intersection
 *
 *  Obstacle
 *  - Drives forward with minimum speed (does not block intersection)
 *
 *  Intersection
 *  - At position 0 (on both the robot's and the obstacle's path)
 *
 *  Liveness property:
 *  - Robot can cross intersection
 *
 *  Safety property:
 *  - Robot and obstacle are not at the intersection at the same time
 *
 */

Functions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
	R Vmin().    /* obstacle minimum speed */
	R ixr() = ( 0 ). /* position of intersection on path of robot */
	R ixo() = ( 0 ). /* position of intersection on path of obstacle */

	R minV() = ( A()*ep() ).

	R stopDist(R) = ( (.)^2/(2*b()) ).
	R accComp(R)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*(.)) ).

	B OAfterX(R) <-> ( (.)>ixo() ).
	B RAfterX(R) <-> ( (.)>ixr() ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmin() > 0
  ).
  B initialState() <-> (                                                   /* Somewhere before intersection initially */
    vr = 0
    & vo>=Vmin()
    & xr < ixr()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B loopinv() <-> (
	  0 <= vr & Vmin()<=vo & (OAfterX(xr) | OAfterX(xo) | xr + stopDist(vr) < ixr() |
	    (vr>0 & ( xo+vo*(ixr()-xr)/vr+A/2*((ixr()-xr)/vr)^2 < ixo()
              | ixo() < xo + Vmin()*(ixr()-xr)/vr))
    )
	).
End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xo.		/* obstacle position */
	R vo.   /* obstacle velocity */
	R ao.   /* obstacle acceleration */
	R t.		/* control cycle time */
End.

Problem.
  assumptions()
	  ->
	  /* safety */
	  [
      {	/* obstacle */
        {
          ao := *; ?-b()<=ao&ao<=A();
        }
        /* robot */
        {
        {
          if (RAfterX(xr) | OAfterX(xo)) {
            ar := *; ?-b()<=ar&ar<=A();
          } else { if (/*PassFaster*/ vr>0 & ( xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()
                                             | ixo() < xo + Vmin()*(ixr()-xr)/(vr+A()*ep()) ) ) {
            ar := *; ?0<=ar&ar<=A();
          } else { if (/*PassCoast*/ vr>0 & ixo() < xo + Vmin()*(ixr()-xr)/vr) {
            ar := 0;
          } else {         /* 1D Model 3 */
              ar := -b();
           ++ ?vr = 0; ar := 0;
           ++ ?xr + stopDist(vr) + accComp(vr) < ixr(); ar := A();
          }}}
        }
        /* dynamics */
        t := 0;
        }
        {xr' = vr, vr' = ar, xo'=vo, vo'=ao, t' = 1 & t <= ep() & vr >= 0 & vo>=Vmin() }
      }*@invariant(loopinv())
		] (xr=ixr() -> xo!=ixo())
		&
		/* liveness */
		<
      {	/* obstacle */
        {
          ao := *; ?-b()<=ao&ao<=A();
        }
        /* robot */
        {
        {
          if (RAfterX(xr) | OAfterX(xo)) {
            ar := *; ?-b()<=ar&ar<=A();
          } else { if (/*PassFaster*/ vr>0 & ( xo+vo*(ixr()-xr)/vr+A()/2*((ixr()-xr)/vr)^2 < ixo()
                                             | ixo() < xo + Vmin()*(ixr()-xr)/(vr+A()*ep()) ) ) {
            ar := *; ?0<=ar&ar<=A();
          } else { if (/*PassCoast*/ vr>0 & ixo() < xo + Vmin()*(ixr()-xr)/vr) {
            ar := 0;
          } else {         /* 1D Model 3 */
              ar := -b();
           ++ ?vr = 0; ar := 0;
           ++ ?xr + stopDist(vr) + accComp(vr) < ixr(); ar := A();
          }}}
        }
        /* dynamics */
        t := 0;
        }
        {xr' = vr, vr' = ar, xo' = vo, vo' = ao, t' = 1 & t <= ep() & vr >= 0 & vo>=Vmin() }
      }*
		>(RAfterX(xr))
End.

Tactic "Proof Theorem 12: Cross intersection".
  implyR(1) ; andR(1) ; <(
  loop({`0<=vr&Vmin()<=vo&(xr>0|xo>0|xr+vr^2/(2*b()) < 0|vr>0&(xo+vo*(0-xr)/vr+A()/2*((0-xr)/vr)^2 < 0|0 < xo+Vmin()*(0-xr)/vr))`}, 1) ; <(
    QE,
    QE,
    composeb(1) ; composeb(1.1) ; solve(1.1.1) ; chase(1) ; allR(1) ; implyR(1) ; andL(-1) ; andL(-7) ; andR(1) ; <(
      implyR(1) ; allR(1) ; implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; orL(-9) ; <(
        fullSimplify ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; hideR(2) ; QE
            )
          ),
        fullSimplify ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; hideR(3) ; hideR(1) ; QE
            )
          )
        ),
      implyR(1) ; andR(1) ; <(
        implyR(1) ; andL(-10) ; fullSimplify ; allR(1) ; implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
          QE,
          andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; orR(3) ; hideL(-7) ; hideR(3) ; andR(3) ; <(
              QE,
              orR(3) ; orL(-9) ; <(
                hideR(4) ; hideL(-7) ; hideR(2) ; QE,
                hideL(-7) ; hideR(3) ; hideR(2) ; QE
                )
              )
            )
          ),
        implyR(1) ; andR(1) ; <(
          implyR(1) ; andL(-11) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
            QE,
            orR(1) ; orR(2) ; orR(3) ; orR(4) ; hideR(4) ; hideR(3) ; hideL(-7) ; hideL(-7) ; hideL(-7) ; QE
            ),
          implyR(1) ; andR(1) ; <(
            notOr(-9) ; andL(-9) ; notAnd(-9) ; notAnd(-10) ; fullSimplify ; allR(1) ; implyR(1) ; implyR(1) ; andR(1) ; <(
              QE,
              andR(1) ; <(
                QE,
                orR(1) ; orR(2) ; orR(3) ; orL(-8) ; <(
                  hideR(4) ; hideR(1) ; hideR(1) ; hideL(-9) ; hideL(-9) ; QE,
                  andL(-8) ; fullSimplify ; fullSimplify ; closeFalse
                  )
                )
              ),
            andR(1) ; <(
              implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; fullSimplify ; andR(1) ; <(
                QE,
                QE
                ),
              implyR(1) ; allR(1) ; implyR(1) ; implyR(1) ; hideL(-10) ; hideL(-10) ; hideL(-9) ; hideL(-8) ; andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  orR(1) ; orR(2) ; orR(3) ; hideR(4) ; hideR(1) ; hideR(1) ; QE
                  )
                )
              )
            )
          )
        )
      )
    ),
  con({`A()>0&b()>0&ep()>0&Vmin()>0&vo>=Vmin()&vr>=0&(xo<=0->vr=0)&\exists n (n>=2&xo+(v-n)*ep()*Vmin()>0&vr+(min((v,n-1))-(n-2))*ep()*A()>=A()*ep()&(xr>0|xr+min((v,n-2))*ep()*(A()*ep())>0))`}, 1) ; <(
    QE,
    composed(1) ; composed(1.1) ; solve(1.1.1) ; composed(1) ; randomd(1) ; existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
      QE,
      composed(1) ; andL(-2) ; andL(-3) ; andL(-4) ; andL(-5) ; andL(-6) ; andL(-7) ; andL(-8) ; existsL(-9) ; andL(-9) ; andL(-10) ; andL(-11) ; choiced(1) ; orR(1) ; composed(1) ; testd(1) ; orL(-12) ; <(
        hideR(2) ; fullSimplify ; composed(1) ; randomd(1) ; implyL(-8) ; <(
          cut({`xo+vo*ep()>0|xo+vo*ep()<=0`}) ; <(
            orL(-12) ; <(
              existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                QE,
                assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                  QE,
                  andR(1) ; <(
                    QE,
                    fullSimplify ; andR(1) ; <(
                      QE,
                      existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                        QE,
                        andR(1) ; <(
                          QE,
                          QE
                          )
                        )
                      )
                    )
                  )
                ),
              hideR(1) ; QE
              ),
            hideR(1) ; QE
            ),
          cut({`xo+vo*ep()>0|xo+vo*ep()<=0`}) ; <(
            orL(-13) ; <(
              existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                QE,
                assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                  QE,
                  andR(1) ; <(
                    QE,
                    fullSimplify ; andR(1) ; <(
                      QE,
                      existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                        QE,
                        andR(1) ; <(
                          QE,
                          QE
                          )
                        )
                      )
                    )
                  )
                ),
              existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
                QE,
                assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                  QE,
                  andR(1) ; <(
                    QE,
                    fullSimplify ; existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                      QE,
                      andR(1) ; <(
                        QE,
                        QE
                        )
                      )
                    )
                  )
                )
              ),
            hideR(1) ; QE
            )
          ),
        composed(2) ; testd(2) ; implyL(-8) ; <(
          andR(1) ; <(
            hideR(2) ; QE,
            hideR(2) ; composed(1) ; randomd(1) ; existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
              QE,
              assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                QE,
                andR(1) ; <(
                  QE,
                  fullSimplify ; andR(1) ; <(
                    QE,
                    existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                      QE,
                      andR(1) ; <(
                        QE,
                        QE
                        )
                      )
                    )
                  )
                )
              )
            ),
          andR(1) ; <(
            andR(2) ; <(
              QE,
              choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; andR(2) ; <(
                QE,
                choiced(2) ; orR(2) ; hideR(2) ; composed(2) ; testd(2) ; andR(2) ; <(
                  QE,
                  choiced(2) ; orR(2) ; hideR(2) ; choiced(2) ; orR(2) ; hideR(3) ; composed(2) ; testd(2) ; fullSimplify ; assignd(2) ; assignd(2) ; existsR({`ep()`}, 2) ; andR(2) ; <(
                    QE,
                    andR(2) ; <(
                      QE,
                      fullSimplify ; existsR({`n`}, 2) ; fullSimplify ; andR(2) ; <(
                        QE,
                        andR(2) ; <(
                          QE,
                          QE
                          )
                        )
                      )
                    )
                  )
                )
              ),
            hideR(2) ; composed(1) ; randomd(1) ; cut({`xo+vo*ep()>0|xo+vo*ep()<=0`}) ; <(
              orL(-13) ; <(
                existsR({`A()`}, 1) ; testd(1) ; andR(1) ; <(
                  QE,
                  assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                    QE,
                    andR(1) ; <(
                      QE,
                      fullSimplify ; andR(1) ; <(
                        QE,
                        existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                          QE,
                          andR(1) ; <(
                            QE,
                            QE
                            )
                          )
                        )
                      )
                    )
                  ),
                existsR({`0`}, 1) ; testd(1) ; andR(1) ; <(
                  QE,
                  assignd(1) ; existsR({`ep()`}, 1) ; andR(1) ; <(
                    QE,
                    andR(1) ; <(
                      QE,
                      fullSimplify ; existsR({`n`}, 1) ; fullSimplify ; andR(1) ; <(
                        QE,
                        andR(1) ; <(
                          QE,
                          QE
                          )
                        )
                      )
                    )
                  )
                ),
              hideR(1) ; QE
              )
            )
          )
        )
      ),
    QE
    )
  )
End.

End.

Theorem "Theorem 14: Reach waypoint with deadline".

/*
 *	Robot must stop within distance delta at goal.
 *
 *  Robot
 * 	- must stop within distance delta of goal
 *  - can only drive straight and forward
 *  - ensures progress towards goal
 *
 *  Liveness property:
 *  - Robot can stop at goal
 *
 */

Functions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R GDelta().	 /* goal area size */
	R Vmax().    /* robot cannot go faster than this */

	R waypointStartDist(R) = ( (.)-GDelta() ).
	R waypointEndDist(R)   = ( (.)+GDelta() ).

  R minV() = ( A()*ep() ).
  R maxTravelTime(R) = ( waypointStartDist(.)/minV() ).
  R stopTime(R)      = ( (.)/b() ).
  R speedUpTime(R)   = ( ep()-(.)/A() ).

	R stopDist(R) = ( (.)^2/(2*b()) ).
	R accComp(R)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*(.)) ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmax() >= 2*A()*ep()
    & GDelta() > Vmax()*ep() + Vmax()^2/(2*b())                            /* waypoint is large enough that robot can
                                                                                  start driving and still stop inside */
    & T > ep() + maxTravelTime(xg-xr) + ep() + stopTime(Vmax())
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    vr = 0
    & xr < waypointStartDist(xg)
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B loopinv() <-> (
	  0 <= vr & vr <= Vmax & xr + stopDist(vr) < waypointEndDist(xg)
    				& (waypointStartDist(xg) < xr -> (vr = 0 | T >= stopTime(vr)))
    				& (xr <= waypointStartDist(xg) ->
    				       (vr >= minV() & T > maxTravelTime(xg-xr) + ep() + stopTime(Vmax()))
    				     | (vr <= minV() & T > speedUpTime(vr) + maxTravelTime(xg-xr) + ep() + stopTime(Vmax())))
	).
End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xg.		/* goal position */
	R t.		/* control cycle time */
	R T.		/* global time */
End.

Problem.
  assumptions()
	  -> [
  			{	{
  			  {
  			     if (xr > waypointStartDist(xg)) {
  			       /* in the goal area: brake or stay stopped */
  			       ar := -b(); ++ ?vr = 0; ar := 0;
  			     } else {
  			       if (xr + stopDist(vr) + accComp(vr) < waypointEndDist(xg) & vr+A()*ep() <= Vmax()) {
  			         /* if robot can stop from higher speed before leaving goal area then accelerate */
  			         ar := A();
  			       } else {
  				       /* else coast until at goal */
  				       ar := 0;
  				     }
  				   }
          }
				  /* dynamics */
				  t := 0;
				  }
				  {xr' = vr, vr' = ar, t' = 1, T'=-1 & t <= ep() & vr >= 0}
			  }*@invariant(loopinv())
		] (xr < waypointEndDist(xg) & (T <= 0 -> (waypointStartDist(xg) < xr & vr = 0)))
End.

Tactic "Proof Theorem 14: Reach waypoint with deadline".
  /* Proves with Z3 */
  implyR(1); (andL('L)*);
  /* normalize else conditions */
  notGreater(1.0.0.0.0.1.0.0) ;
  notAnd(1.0.0.0.0.1.1.1.0.0) ; notLess(1.0.0.0.0.1.1.1.0.0.0) ; notLessEqual(1.0.0.0.0.1.1.1.0.0.1);
  /* loop induction */
  loop({`loopinv()`}, 1); <(
    print({`Base case`}); QE; done
    ,
    print({`Use case`}); QE; done
    ,
    print({`Induction step`}); unfold;
    doall(ODE('R); allR('R); (implyR('R)*2); allL({`t_`}, 'Llast); QE); done
  );
  done;
  print({`Proof done`})
End.

End.
