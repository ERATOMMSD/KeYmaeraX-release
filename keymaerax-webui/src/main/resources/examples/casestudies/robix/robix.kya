Theorem "Theorem 1: Static safety".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b())).              /* The straight-line stopping distance from brake start to full stop. */
  R accelComp(R) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*(.)))./* Straight-line distance to compensate acceleration */
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).     /* Separation that allows accelerating on a new curve */

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](x - xo)^2 + (y - yo)^2 > 0
End.

Tactic "Proof Theorem 1: Static safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo)>v_0^2/(2*b())+(A()/b()+1)*(A()/2*t^2+t*v_0)`}, 'L=={`abs(x_0-xo)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo)>v_0^2/(2*b())+(A()/b()+1)*(A()/2*t^2+t*v_0)`}, 'L=={`abs(y_0-yo)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`abs(x-xo_0)>stopDist(v)|abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 2: Passive safety".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b()) + V()*(.)/b()).
  R accelComp(R) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*((.)+V))).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 2: Passive safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 4: Passive orientation safety".
Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Gamma().   /* Sensor range in radian */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R)   = ( (.)^2 / (2*b()) ).
  R stopMargin(R) = ( stopDist(.) + V()*(.)/b() ).
  R accelComp(R)  = ( (A()/b() + 1) * (A()/2 * ep()^2 + ep()*(.)) ).
  R accelMargin(R)  = ( accelComp(.) + (A()/b() + 1)*ep()*V() ).
  R admissibleSeparation(R) = ( stopMargin(.) + accelMargin(.) ).
  R admissibleTurnLength(R) = ( stopDist(.) + accelComp(.) ).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B isVisible(R) <-> ((.)>0).      /* Indicates whether or not the obstacle is visible for the robot at the decision. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Gamma() > 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & beta = 0
    & r != 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & r != 0
    & (v>0 -> ( (abs(x-xo) > stopMargin(v) | abs(y-yo) > stopMargin(v))
              | (!isVisible(visDeg) & abs(beta) + stopDist(v)/abs(r) < Gamma() )) )
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
  R beta. /* Angle that the robot traveled since it last chose a new curve */
  R visDeg. /* Indicates the "degree" to which the obstacle is visible to the robot (input to isVisible) */
End.

Problem.
  assumptions() -> [
      {
        {
        /* obstacle control */
        {
          vxo := *;
          vyo := *;
          ?vxo^2+vyo^2 <= V()^2;
        }

        /* robot control */
        {
           /* brake on current curve. If the velocity is zero this just means that the robot remains stopped */
           {a := -b();}
        ++ /* When we are stopped, both translational and rotational acceleration are 0 */
           {?v=0; a := 0; w := 0;}
        ++ /* or choose a new safe curve */
           {a := A();
            beta := 0;
            r :=*; ?r!=0;

            /* measure obstacle position and whether or not it is visible to the robot */
            xo := *; yo := *; visDeg := *;
            ?(isVisible(visDeg) ->
               ( abs(x-xo) > admissibleSeparation(v)
               | abs(y-yo) > admissibleSeparation(v)) );
            ?admissibleTurnLength(v) < Gamma()*abs(r);
            }
        }

        /* Reset the clocks */
        t := 0;
        /* Set w according to physics (rigid body motion) */
        w :=*; ?w*r = v;
        }

        {x' = v * dx, y' = v * dy, dx' = -w * dy, dy' = w * dx, v' = a, w' = a/r, beta'=w,
                      xo' = vxo, yo' = vyo, t' = 1 & (t <= ep & v >= 0)}
      }*
    ] (v > 0 -> ((x - xo)^2 + (y - yo)^2 > 0 | (!isVisible(visDeg) & (abs(beta) < Gamma()))) )
End.

Tactic "Proof Theorem 4: Passive orientation safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1);
    diffInvariant({`w*r=v`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`beta = old(beta) + t/r*(v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`beta = old(beta)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`beta = old(beta) + t/r*(v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    hideR('R=={`abs(y-yo)>stopMargin(v)`});
    hideL('L=={`-t*(v-A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v-A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+((A()/b()+1)*(A()/2*t^2+t*v_0)+(A()/b()+1)*t*V())`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    hideR('R=={`abs(x-xo)>stopMargin(v)`});
    hideL('L=={`-t*(v-A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v-A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+((A()/b()+1)*(A()/2*t^2+t*v_0)+(A()/b()+1)*t*V())`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop ; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0->((abs(x-xo_0)>stopMargin(v)|abs(y-yo_0)>stopMargin(v))|!isVisible(visDeg_0)&abs(beta_0)+stopDist(v)/abs(r_0) < Gamma())`});
      unfold;
      dia; dw;
      print({`Acceleration arithmetic`});
      implyR(1) ; andL('L)* ; fullSimplify ; implyR(1) ; orR(1) ; notGreater(2.0) ; orR(1) ;
      implyL('L=={`isVisible(visDeg) -> ( abs(x_0-xo_0) > admissibleSeparation(v_0) | abs(y_0-yo_0) > admissibleSeparation(v_0))`}) ; <(
        hideR('R=={`abs(x-xo)>stopMargin(v)`}) ; hideR('R=={`abs(y-yo)>stopMargin(v)`}) ; andR(1) ; doall(smartQE)
        ,
        print({`Acc Distance`});
        hideL('L=={`admissibleTurnLength(v_0) < Gamma()*abs(r)`}) ;
        hideR('R=={`visDeg<=0 & abs(beta) + stopDist(v)/abs(r) < Gamma()`});
        hideL('L=={`r_0!=0`});
        hideL('L=={`vxo^2+vyo^2<=V()^2`});
        hideL('L=={`dx^2+dy^2=1`});
        hideL('L=={`Gamma()>0`});
        hideL('L=={`beta_0=0`});
        hideL('L=={`w*r=v`});
        hideL('L=={`beta=beta_0+t/r*(v-A()/2*t)`});
        orL('L=={`abs(x_0-xo_0)>admissibleSeparation(v_0) | abs(y_0-yo_0)>admissibleSeparation(v_0)`}); <(
          xAccArith
          ,
          yAccArith
        )
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 5: Passive safety with actual acceleration".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b()) + V()*(.)/b()).
  /*R accelComp(R) = ((a/b() + 1) * (a/2 * ep()^2 + ep()*((.)+V))).
  R admissibleSeparationG(R) = (stopDist(.) + accelComp(.)).
  R admissibleSeparationL(R) = (-(.)^2/(2*a)-V*(.)/a).*/

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := *; ?-b<=a & a<=A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            if (v+a*ep>=0) { ?abs(x-xo) > stopDist(v) + (a/b+1)*(a/2*ep^2 + ep*(v+V)) | abs(y-yo) > stopDist(v) + (a/b+1)*(a/2*ep^2 + ep*(v+V)); }
            else           { ?abs(x-xo) > -v^2/(2*a)-V*v/a | abs(y-yo) > -v^2/(2*a)-V*v/a; }
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 5: Passive safety with actual acceleration".
  tactic diall as (
    diffInvariant({`t>=0`}, 'R);
    diffInvariant({`isWellformedDir()`}, 'R);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 'R);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 'R)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 'R);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 'R);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 'R)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 'R);
    diffInvariant({`x = old(x)`}, 'R);
    diffInvariant({`y = old(y)`}, 'R)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + a*t`}, 'R);
    diffInvariant({`-t * (v - a/2*t) <= x - old(x) & x - old(x) <= t * (v - a/2*t)`}, 'R);
    diffInvariant({`-t * (v - a/2*t) <= y - old(y) & y - old(y) <= t * (v - a/2*t)`}, 'R)
  );

  tactic dw as (andL('L)*; dW('R));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    ?(transform({`abs(x_0-xo_0)>stopDist(v_0) + (a/b+1)*(a/2*t^2 + t*(v_0+V))`}, 'L=={`abs(x_0-xo_0)>stopDist(v_0) + (a/b+1)*(a/2*ep^2 + ep*(v_0+V))`}));
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    ?(transform({`abs(y_0-yo_0)>stopDist(v_0) + (a/b+1)*(a/2*t^2 + t*(v_0+V))`}, 'L=={`abs(y_0-yo_0)>stopDist(v_0) + (a/b+1)*(a/2*ep^2 + ep*(v_0+V))`}));
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Free driving non-stopping branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Free driving non-stopping branch done`})
      ,
      print({`Free driving stopping branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Free driving stopping branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 6: Passive safety despite location uncertainty".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Dp().      /* maximum location uncertainty */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b()) + V()*(.)/b()).
  R accelComp(R) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*((.)+V())) + Dp()).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Dp() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R mx.   /* robot measured position: x */
  R my.   /* robot measured position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* locate */
        {
          mx := *; my := *;
          ?(mx-x)^2+(my-y)^2 <= Dp()^2;
        }
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(mx-xo) > admissibleSeparation(v)
            | abs(my-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 6: Passive safety despite location uncertainty".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(mx-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))+Dp()`}, 'L=={`abs(mx-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(my-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))+Dp()`}, 'L=={`abs(my-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 7: Passive safety despite actuator perturbation".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Da().      /* maximum actuator perturbation 0< Da <= 1 (robot will not loose brakes entirely) */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ( (.)^2 / (2*(b()*Da())) + V()*(.)/(b()*Da()) ).
  R accelComp(R) = ( (A()/(b()*Da()) + 1) * (A()/2 * ep()^2 + ep()*((.)+V())) ).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & 0 < Da() & Da() <= 1
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot control choice: translational acceleration */
  R da.   /* robot actuator disturbance */
  R acc.  /* robot actual translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
        /* actuator perturbation */
        {
          da := *; ?(Da<=da & da<=1); acc := da*a;
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = acc,      /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = acc/r, /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 7: Passive safety despite actuator perturbation".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v <= old(v) - (b()*Da())*t`}, 1);
    diffInvariant({`-t * (old(v) - (b()*Da())/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - (b()*Da())/2*t)`}, 1);
    diffInvariant({`-t * (old(v) - (b()*Da())/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - (b()*Da())/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v <= old(v) + A()*t`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*(b()*Da()))+V()*v_0/(b()*Da())+(A()/(b()*Da())+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE);
    hideL('L=={`t<=ep()`});
    hideL('L=={`b()>0`});
    hideL('L=={`ep()>0`});
    hideL('L=={`0<Da()`});
    hideL('L=={`Da()<=1`});
    hideL('L=={`Da()<=da`});
    hideL('L=={`da<=1`});
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*(b()*Da()))+V()*v_0/(b()*Da())+(A()/(b()*Da())+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE);
    hideL('L=={`t<=ep()`});
    hideL('L=={`b()>0`});
    hideL('L=={`ep()>0`});
    hideL('L=={`0<Da()`});
    hideL('L=={`Da()<=1`});
    hideL('L=={`Da()<=da`});
    hideL('L=={`da<=1`});
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE); prop; doall(print({`Braking QE`}); smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 8: Passive safety despite velocity uncertainty".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Dv().      /* maximum velocity uncertainty */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ( (.)^2 / (2*b()) + V()*(.)/b() ).
  R accelComp(R) = ( (A()/b() + 1) * (A()/2 * ep()^2 + ep()*((.)+V())) ).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Dv() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R mv.   /* robot measured velocity */
  R a.    /* robot control choice: translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* sense */
        {
          mv := *; ?0<=mv & v-Dv()<=mv & mv<=v+Dv();
        }
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(mv+Dv())
            | abs(y-yo) > admissibleSeparation(mv+Dv());
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 8: Passive safety despite velocity uncertainty".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v <= old(v) - b()*t`}, 1);
    diffInvariant({`-t * (old(v) - b()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) - b()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v <= old(v) + A()*t`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(mv+Dv())`});
    hideL('L=={`t<=ep()`});
    hideL('L=={`ep()>0`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(mv+Dv())`});
    hideL('L=={`t<=ep()`});
    hideL('L=={`ep()>0`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(print({`Braking QE`}); smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 14: Reach waypoint with deadline".

/*
 *	Robot must stop within distance delta at goal.
 *
 *  Robot
 * 	- must stop within distance delta of goal
 *  - can only drive straight and forward
 *  - ensures progress towards goal
 *
 *  Liveness property:
 *  - Robot can stop at goal
 *
 */

Functions.
	R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R GDelta().	 /* goal area size */
	R Vmax().    /* robot cannot go faster than this */

	R waypointStartDist(R) = ( (.)-GDelta() ).
	R waypointEndDist(R)   = ( (.)+GDelta() ).

  R minV() = ( A()*ep() ).
  R maxTravelTime(R) = ( waypointStartDist(.)/minV() ).
  R stopTime(R)      = ( (.)/b() ).
  R speedUpTime(R)   = ( ep()-(.)/A() ).

	R stopDist(R) = ( (.)^2/(2*b()) ).
	R accComp(R)  = ( (A()/b() + 1)*(A()/2*ep()^2 + ep()*(.)) ).

	B bounds() <-> (                                                                     /* Bounds for global constants */
      A() > 0                                                                                       /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & Vmax() >= 2*A()*ep()
    & GDelta() > Vmax()*ep() + Vmax()^2/(2*b())                            /* waypoint is large enough that robot can
                                                                                  start driving and still stop inside */
    & T > ep() + maxTravelTime(xg-xr) + ep() + stopTime(Vmax())
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    vr = 0
    & xr < waypointStartDist(xg)
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

	B loopinv() <-> (
	  0 <= vr & vr <= Vmax & xr + stopDist(vr) < waypointEndDist(xg)
    				& (waypointStartDist(xg) < xr -> (vr = 0 | T >= stopTime(vr)))
    				& (xr <= waypointStartDist(xg) ->
    				       (vr >= minV() & T > maxTravelTime(xg-xr) + ep() + stopTime(Vmax()))
    				     | (vr <= minV() & T > speedUpTime(vr) + maxTravelTime(xg-xr) + ep() + stopTime(Vmax())))
	).
End.

ProgramVariables.
	R xr.		/* robot position: x */
	R vr.		/* robot translational velocity */
	R ar.		/* robot translational acceleration */
	R xg.		/* goal position */
	R t.		/* control cycle time */
	R T.		/* global time */
End.

Problem.
  assumptions()
	  -> [
  			{	{
  			  {
  			     if (xr > waypointStartDist(xg)) {
  			       /* in the goal area: brake or stay stopped */
  			       ar := -b(); ++ ?vr = 0; ar := 0;
  			     } else {
  			       if (xr + stopDist(vr) + accComp(vr) < waypointEndDist(xg) & vr+A()*ep() <= Vmax()) {
  			         /* if robot can stop from higher speed before leaving goal area then accelerate */
  			         ar := A();
  			       } else {
  				       /* else coast until at goal */
  				       ar := 0;
  				     }
  				   }
          }
				  /* dynamics */
				  t := 0;
				  }
				  {xr' = vr, vr' = ar, t' = 1, T'=-1 & t <= ep() & vr >= 0}
			  }*@invariant(loopinv())
		] (xr < waypointEndDist(xg) & (T <= 0 -> (waypointStartDist(xg) < xr & vr = 0)))
End.

Tactic "Proof Theorem 14: Reach waypoint with deadline".
  /* Proves with Z3 */
  implyR(1); (andL('L)*);
  /* normalize else conditions */
  notGreater(1.0.0.0.0.1.0.0) ;
  notAnd(1.0.0.0.0.1.1.1.0.0) ; notLess(1.0.0.0.0.1.1.1.0.0.0) ; notLessEqual(1.0.0.0.0.1.1.1.0.0.1);
  /* loop induction */
  loop({`loopinv()`}, 1); <(
    print({`Base case`}); QE; done
    ,
    print({`Use case`}); QE; done
    ,
    print({`Induction step`}); unfold;
    doall(ODE('R); allR('R); (implyR('R)*2); allL({`t_`}, 'Llast); QE); done
  );
  done;
  print({`Proof done`})
End.

End.
