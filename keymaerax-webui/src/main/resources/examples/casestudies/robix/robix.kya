Theorem "Theorem 1: Static safety".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b())).              /* The straight-line stopping distance from brake start to full stop. */
  R accelComp(R) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*(.)))./* Straight-line distance to compensate acceleration */
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).     /* Separation that allows accelerating on a new curve */

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](x - xo)^2 + (y - yo)^2 > 0
End.

Tactic "Proof Theorem 1: Static safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo)>v_0^2/(2*b())+(A()/b()+1)*(A()/2*t^2+t*v_0)`}, 'L=={`abs(x_0-xo)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo)>v_0^2/(2*b())+(A()/b()+1)*(A()/2*t^2+t*v_0)`}, 'L=={`abs(y_0-yo)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`abs(x-xo_0)>stopDist(v)|abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 2: Passive safety".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b()) + V()*(.)/b()).
  R accelComp(R) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*((.)+V))).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 2: Passive safety".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 5: Passive safety with actual acceleration".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b()) + V()*(.)/b()).
  /*R accelComp(R) = ((a/b() + 1) * (a/2 * ep()^2 + ep()*((.)+V))).
  R admissibleSeparationG(R) = (stopDist(.) + accelComp(.)).
  R admissibleSeparationL(R) = (-(.)^2/(2*a)-V*(.)/a).*/

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := *; ?-b<=a & a<=A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            if (v+a*ep>=0) { ?abs(x-xo) > stopDist(v) + (a/b+1)*(a/2*ep^2 + ep*(v+V)) | abs(y-yo) > stopDist(v) + (a/b+1)*(a/2*ep^2 + ep*(v+V)); }
            else           { ?abs(x-xo) > -v^2/(2*a)-V*v/a | abs(y-yo) > -v^2/(2*a)-V*v/a; }
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 5: Passive safety with actual acceleration".
  tactic diall as (
    diffInvariant({`t>=0`}, 'R);
    diffInvariant({`isWellformedDir()`}, 'R);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 'R);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 'R)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 'R);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 'R);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 'R)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 'R);
    diffInvariant({`x = old(x)`}, 'R);
    diffInvariant({`y = old(y)`}, 'R)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + a*t`}, 'R);
    diffInvariant({`-t * (v - a/2*t) <= x - old(x) & x - old(x) <= t * (v - a/2*t)`}, 'R);
    diffInvariant({`-t * (v - a/2*t) <= y - old(y) & y - old(y) <= t * (v - a/2*t)`}, 'R)
  );

  tactic dw as (andL('L)*; dW('R));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    ?(transform({`abs(x_0-xo_0)>stopDist(v_0) + (a/b+1)*(a/2*t^2 + t*(v_0+V))`}, 'L=={`abs(x_0-xo_0)>stopDist(v_0) + (a/b+1)*(a/2*ep^2 + ep*(v_0+V))`}));
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    ?(transform({`abs(y_0-yo_0)>stopDist(v_0) + (a/b+1)*(a/2*t^2 + t*(v_0+V))`}, 'L=={`abs(y_0-yo_0)>stopDist(v_0) + (a/b+1)*(a/2*ep^2 + ep*(v_0+V))`}));
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Free driving non-stopping branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Free driving non-stopping branch done`})
      ,
      print({`Free driving stopping branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Free driving stopping branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 6: Passive safety despite location uncertainty".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Dp().      /* maximum location uncertainty */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ((.)^2 / (2*b()) + V()*(.)/b()).
  R accelComp(R) = ((A()/b() + 1) * (A()/2 * ep()^2 + ep()*((.)+V())) + Dp()).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Dp() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R mx.   /* robot measured position: x */
  R my.   /* robot measured position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* locate */
        {
          mx := *; my := *;
          ?(mx-x)^2+(my-y)^2 <= Dp()^2;
        }
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(mx-xo) > admissibleSeparation(v)
            | abs(my-yo) > admissibleSeparation(v);
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 6: Passive safety despite location uncertainty".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v = old(v) - b()*t`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= x - old(x) & x - old(x) <= t * (v + b()/2*t)`}, 1);
    diffInvariant({`-t * (v + b()/2*t) <= y - old(y) & y - old(y) <= t * (v + b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v = old(v) + A()*t`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= x - old(x) & x - old(x) <= t * (v - A()/2*t)`}, 1);
    diffInvariant({`-t * (v - A()/2*t) <= y - old(y) & y - old(y) <= t * (v - A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(mx-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))+Dp()`}, 'L=={`abs(mx-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(my-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))+Dp()`}, 'L=={`abs(my-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 7: Passive safety despite actuator perturbation".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Da().      /* maximum actuator perturbation 0< Da <= 1 (robot will not loose brakes entirely) */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ( (.)^2 / (2*(b()*Da())) + V()*(.)/(b()*Da()) ).
  R accelComp(R) = ( (A()/(b()*Da()) + 1) * (A()/2 * ep()^2 + ep()*((.)+V())) ).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & 0 < Da() & Da() <= 1
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R a.    /* robot control choice: translational acceleration */
  R da.   /* robot actuator disturbance */
  R acc.  /* robot actual translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(v)
            | abs(y-yo) > admissibleSeparation(v);
          }
        };
        /* actuator perturbation */
        {
          da := *; ?(Da<=da & da<=1); acc := da*a;
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = acc,      /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = acc/r, /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 7: Passive safety despite actuator perturbation".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v <= old(v) - (b()*Da())*t`}, 1);
    diffInvariant({`-t * (old(v) - (b()*Da())/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - (b()*Da())/2*t)`}, 1);
    diffInvariant({`-t * (old(v) - (b()*Da())/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - (b()*Da())/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v <= old(v) + A()*t`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*(b()*Da()))+V()*v_0/(b()*Da())+(A()/(b()*Da())+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE);
    hideL('L=={`t<=ep()`});
    hideL('L=={`b()>0`});
    hideL('L=={`ep()>0`});
    hideL('L=={`0<Da()`});
    hideL('L=={`Da()<=1`});
    hideL('L=={`Da()<=da`});
    hideL('L=={`da<=1`});
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*(b()*Da()))+V()*v_0/(b()*Da())+(A()/(b()*Da())+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(v_0)`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE);
    hideL('L=={`t<=ep()`});
    hideL('L=={`b()>0`});
    hideL('L=={`ep()>0`});
    hideL('L=={`0<Da()`});
    hideL('L=={`Da()<=1`});
    hideL('L=={`Da()<=da`});
    hideL('L=={`da<=1`});
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; abbrv({`b*Da()`},{`actB`}); cut({`actB>0`}); <(hideL('L=={`actB=b*Da()`}), hideR(1); smartQE); prop; doall(print({`Braking QE`}); smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.

Theorem "Theorem 8: Passive safety despite velocity uncertainty".

Functions.
  R ep().      /* time limit for control decisions */
  R b().       /* minimum braking capability of the robot */
  R A().       /* maximum acceleration -b <= a <= A */
  R W().       /* maximum steering */
  R V().       /* maximum obstacle velocity */
  R Dv().      /* maximum velocity uncertainty */
  R abs(R).    /* predefined function of absolute value */

  R stopDist(R) = ( (.)^2 / (2*b()) + V()*(.)/b() ).
  R accelComp(R) = ( (A()/b() + 1) * (A()/2 * ep()^2 + ep()*((.)+V())) ).
  R admissibleSeparation(R) = (stopDist(.) + accelComp(.)).

  B isWellformedDir() <-> (dx^2 + dy^2 = 1).                        /* The orientation of the robot is a unit vector. */

  B bounds() <-> (                                                                     /* Bounds for global constants */
      A() >= 0                                                                                      /* Working engine */
    & b() > 0                                                                                       /* Working brakes */
    & ep() > 0                                                                            /* Controller reaction time */
    & V() >= 0
    & Dv() >= 0
  ).
  B initialState() <-> (                                                          /* Stopped somewhere safe initially */
    v = 0
    & (x-xo)^2 - (y-yo)^2 > 0
    & isWellformedDir()
  ).
  B assumptions() <-> (bounds() & initialState()).                     /* Under these assumptions we guarantee safety */

  B loopinv() <-> (                                                /* Conditions that are true on each loop iteration */
    v >= 0
    & isWellformedDir()
    & (v>0 -> abs(x-xo) > stopDist(v) | abs(y-yo) > stopDist(v))
  ).
End.

ProgramVariables.
  R x.    /* robot position: x */
  R y.    /* robot position: y */
  R v.    /* robot translational velocity */
  R mv.   /* robot measured velocity */
  R a.    /* robot control choice: translational acceleration */
  R dx.   /* robot orientation: x */
  R dy.   /* robot orientation: y */
  R w.    /* robot rotational velocity */
  R r.    /* robot curve radius */
  R xo.   /* position of closest obstacle on curve */
  R yo.
  R vxo.  /* velocity vector of obstacle */
  R vyo.
  R t.    /* time */
End.

Problem.
assumptions() ->
  [
    {
      {
        /* sense */
        {
          mv := *; ?0<=mv & v-Dv()<=mv & mv<=v+Dv();
        }
        /* obstacle control */
        {
          vxo := *; vyo := *;
          ?vxo^2+vyo^2<=V^2;
        }
        /* robot control */
        {
          /* brake on current curve or remain stopped */
          { a := -b; }
          ++
          { ?v = 0; a := 0; w := 0; }
      	  ++
          /* or choose a new safe curve */
          { a := A;
            w := *; ?-W<=w & w<=W;       /* choose steering */
            r := *;
            xo := *; yo := *;            /* measure closest obstacle on the curve */

            /* admissible curve */
            ?r!=0 & r*w = v;

            /* use that curve, if it is a safe one (admissible velocities) */
            ? abs(x-xo) > admissibleSeparation(mv+Dv())
            | abs(y-yo) > admissibleSeparation(mv+Dv());
          }
        };
    	  t := 0;
      }

      /* dynamics */
      { x' = v * dx, y' = v * dy, v' = a,        /* accelerate/decelerate and move */
        dx' = -w * dy, dy' = w * dx, w' = a/r,   /* follow curve */
        xo' = vxo, yo' = vyo,                    /* obstacle moves */
        t' = 1 & t <= ep & v >= 0
      }
    }*@invariant(loopinv())
  ](v>0 -> (x - xo)^2 + (y - yo)^2 > 0)
End.

Tactic "Proof Theorem 8: Passive safety despite velocity uncertainty".
  tactic diall as (
    diffInvariant({`t>=0`}, 1);
    diffInvariant({`isWellformedDir()`}, 1);
    diffInvariant({`-t*V() <= xo - old(xo) & xo - old(xo) <= t*V()`}, 1);
    diffInvariant({`-t*V() <= yo - old(yo) & yo - old(yo) <= t*V()`}, 1)
  );

  tactic dib as (
    diall;
    diffInvariant({`v <= old(v) - b()*t`}, 1);
    diffInvariant({`-t * (old(v) - b()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) - b()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) - b()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) - b()/2*t)`}, 1)
  );

  tactic di0 as (
    diall;
    diffInvariant({`v = old(v)`}, 1);
    diffInvariant({`x = old(x)`}, 1);
    diffInvariant({`y = old(y)`}, 1)
  );

  tactic dia as (
    diall;
    diffInvariant({`v <= old(v) + A()*t`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= x - old(x) & x - old(x) <= t * (old(v) + A()/2*t)`}, 1);
    diffInvariant({`-t * (old(v) + A()/2*t) <= y - old(y) & y - old(y) <= t * (old(v) + A()/2*t)`}, 1)
  );

  tactic dw as (andL('L)*; dW(1));

  tactic xAccArith as (
    andL('L)*;
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=y-y_0`});
    hideL('L=={`y-y_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=yo-yo_0`});
    hideL('L=={`yo-yo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(x_0-xo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`}, 'L=={`abs(x_0-xo_0)>admissibleSeparation(mv+Dv())`});
    hideL('L=={`t<=ep()`});
    hideL('L=={`ep()>0`});
    hideR('R=={`abs(y-yo)>stopDist(v)`});
    transform({`abs(x_0-xo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(x_0-xo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  tactic yAccArith as (
    andL('L)*;
    hideL('L=={`r!=0`});
    hideL('L=={`vxo^2+vyo^2<=V()^2`});
    hideL('L=={`dx^2+dy^2=1`});
    hideL('L=={`-t*(v_0+A()/2*t)<=x-x_0`});
    hideL('L=={`x-x_0<=t*(v_0+A()/2*t)`});
    hideL('L=={`-t*V()<=xo-xo_0`});
    hideL('L=={`xo-xo_0<=t*V()`});
    print({`Transforming...`});
    transform({`abs(y_0-yo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`}, 'L=={`abs(y_0-yo_0)>admissibleSeparation(mv+Dv())`});
    hideL('L=={`t<=ep()`});
    hideL('L=={`ep()>0`});
    hideR('R=={`abs(x-xo)>stopDist(v)`});
    transform({`abs(y_0-yo_0)>v_0^2/(2*b())+V()*v_0/b()+(A()/b()+1)*(A()/2*t^2+t*(v_0+V()))`}, 'L=={`abs(y_0-yo_0)>(mv+Dv())^2/(2*b())+V()*(mv+Dv())/b()+(A()/b()+1)*(A()/2*t^2+t*((mv+Dv())+V()))`});
    smartQE;
    print({`Proved acc arithmetic`})
  );

  implyR(1); andL('L)*; loop({`loopinv()`}, 1); <(
    print({`Base case...`}); smartQE; print({`Base case done`})
    ,
    print({`Use case...`}); smartQE; print({`Use case done`})
    ,
    print({`Induction step`}); unfold; <(
      print({`Braking branch`}); dib; dw; prop; doall(print({`Braking QE`}); smartQE); print({`Braking branch done`})
      ,
      print({`Stopped branch`}); di0; dw; prop; doall(smartQE); print({`Stopped branch done`})
      ,
      print({`Acceleration branch`});
      hideL('L == {`v>0 -> abs(x-xo_0)>stopDist(v) | abs(y-yo_0)>stopDist(v)`});
      dia; dw;
      prop; <(
        xAccArith,
        yAccArith
      );
      print({`Acceleration branch done`})
    );
    print({`Induction step done`})
  );
  done;
  print({`Proof done`})

End.

End.